
  <!DOCTYPE html>
  <html lang="zh-CN"  
    
      data-theme-mode="auto"
    
  >
  <head>
  
  <meta charset="utf-8">
  
  <script src="https://www.googletagmanager.com/gtag/js?id=true"></script>
  <script data-pjax>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'true');
  </script>


  
  <script>
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "true");
  </script>


  
  <script async src="https://hm.baidu.com/hm.js?true"></script>
  <script data-pjax>
    var _hmt = _hmt || [];
    _hmt.push(["_trackPageview", location.pathname]);
  </script>


  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_0khxww3tj3q9';window.REIMU_CONFIG.clipboard_tips = {"success":"复制成功 ~ (*^▽^*)","fail":"复制失败 !!! (ﾟ⊿ﾟ)ﾂ","copyright":{"enable":false,"count":50,"content":"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！"}};window.REIMU_CONFIG.code_block = {"expand":true};window.REIMU_CONFIG.base = 'https://skipshot.cn';</script>
  
  <title>
    [Algorithm] ZUC —— “祖冲之”流密钥算法的代码解释 |
    
    寂静の - 永恒秋之森 -
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <link rel="preload" as="style" href="https://fontsapi.zeoseven.com/13/main/result.css" onload="this.rel&#x3D;&#39;stylesheet&#39;" crossorigin>
  
  
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=ZCOOL%20KuaiLe:400,400italic,700,700italic%7CMulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CJetBrains%20Mono:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=ZCOOL%20KuaiLe:400,400italic,700,700italic%7CMulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CJetBrains%20Mono:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_0khxww3tj3q9.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="简单介绍一下用python写的ZUC（祖冲之算法），不管什么用语言写，其实现思路还是一样的">
<meta property="og:type" content="article">
<meta property="og:title" content="[Algorithm] ZUC —— “祖冲之”流密钥算法的代码解释">
<meta property="og:url" content="https://skipshot.cn/2025/11/21/Algorithm-25-11-21/index.html">
<meta property="og:site_name" content="寂静の - 永恒秋之森 -">
<meta property="og:description" content="简单介绍一下用python写的ZUC（祖冲之算法），不管什么用语言写，其实现思路还是一样的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://golden-forest.top/dc084f0926201d44aa4cc4c134c743a1.png">
<meta property="og:image" content="https://golden-forest.top/de53110763e7658bc09c79a704b4df5c.png">
<meta property="og:image" content="https://golden-forest.top/190b49413bda101392e6c0fd029fa4af.png">
<meta property="og:image" content="https://golden-forest.top/c0ae5d7201acf6c73161f2a0c68e3c4e.png">
<meta property="og:image" content="https://golden-forest.top/449c2dc27494b41e49e2e9c24daf744a.png">
<meta property="og:image" content="https://golden-forest.top/dec325ab30f47f3c261757530fb9bd3d.png">
<meta property="article:published_time" content="2025-11-21T12:25:05.000Z">
<meta property="article:modified_time" content="2025-11-26T07:27:01.173Z">
<meta property="article:author" content="SkipShot">
<meta property="article:tag" content="StreamCipher">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://golden-forest.top/dc084f0926201d44aa4cc4c134c743a1.png">
  
  
    <link rel="alternate" href="/atom.xml" title="寂静の - 永恒秋之森 -" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
    
      
        
<link rel="stylesheet" href="https://npm.webcache.cn/katex@0.16.11/dist/katex.min.css">

      
    
  
  
  
    
      
<link rel="stylesheet" href="https://npm.webcache.cn/gitalk@1.8.0/dist/gitalk.css">

    
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css">

  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi ">
        
          <img src="/images/foxleep.gif" alt="loading" />
        
      </div>
      <div class="loading-word">少 女 祈 祷 中 ...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon ">
            &#xe607;
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon ">
            &#xe62f;
          </div>
          <a class="main-nav-link" href="/archives">归档</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon ">
            &#xe631;
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon ">
            &#xe628;
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅" target="_blank"></a>
    
    
      <a id="nav-search-btn" class="nav-icon popup-trigger" title="搜索"></a>
    
    
  </nav>
  
</div>
<header id="header">
  
    <picture></picture>
    <img  fetchpriority="high" src="https://golden-forest.top/f47066e331aeeefd695c72ea24d732e1.jpg" alt="[Algorithm] ZUC —— “祖冲之”流密钥算法的代码解释">
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">[Algorithm] ZUC —— “祖冲之”流密钥算法的代码解释</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content"  class="sidebar-right" >
          <aside id="sidebar">
  
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        
          <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#zuc%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text"> ZUC算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text"> 预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E8%A3%85%E5%85%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 密钥装入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8lfsr"><span class="toc-number">1.3.</span> <span class="toc-text"> 线性反馈移位寄存器(LFSR)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 初始模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BD%9C%E4%B8%BA%E5%AF%86%E9%92%A5%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 为什么不能直接作为密钥使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E9%87%8D%E7%BB%84br"><span class="toc-number">1.4.</span> <span class="toc-text"> 比特重组(BR)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0f"><span class="toc-number">1.5.</span> <span class="toc-text"> 非线性函数F</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8D%95%E5%85%83r1-r2"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 记忆单元R1、R2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sbox"><span class="toc-number">1.5.2.</span> <span class="toc-text"> Sbox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 线性变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E9%87%8D%E7%BB%84"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 交叉重组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%A2%B3%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text"> 小梳理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86"><span class="toc-number">1.7.</span> <span class="toc-text"> 加密解密</span></a></li></ol></li></ol>
      
  </div>
</div>
</div>
          <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="SkipShot" class="lazyload">
  <div class="sidebar-author-name">SkipShot</div>
  <div class="sidebar-description">兴趣使然~</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">18</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">6</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">11</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/tgf668 itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon ">
          &#xe607;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon ">
          &#xe62f;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon ">
          &#xe631;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon ">
          &#xe628;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
        
      
      
        
          <div class="sidebar-btn-wrapper" style="position:static">
            <div class="sidebar-toc-btn current"></div>
            <div class="sidebar-common-btn"></div>
          </div>
        
      
    </div>
  </div>

  <div class="sidebar-widget">
  
  </div>
  
</aside>

          <section id="main"><article id="post-Algorithm-25-11-21" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <span class="article-date-link" data-aos="zoom-in">
    <time datetime="2025-11-21T12:25:05.000Z" itemprop="datePublished">2025-11-21</time>
    <time style="display: none;" id="post-update-time">2025-11-26</time>
  </span>
</div>

      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/" data-aos="zoom-in">Algorithm</a>
  </div>


    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="zuc算法分析"><a class="markdownIt-Anchor" href="#zuc算法分析"></a> ZUC算法分析</h1>
<blockquote>
<p>本文写于作者进行密码学课程实验过程中，会以“初学者”的视角去解读。不涉及CTF中的逆向、密码知识，只为做深入理解并为后面复习所用。<strong>文章代码源于AI生成，作者专门调过提示词，按照GB/T33133.1—2016标准设计，可能与其他标准或实现顺序有区别，如有问题，请联系作者：（后面开个仓库）</strong></p>
</blockquote>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>首先，想了解ZUC算法是什么：<code>祖冲之算法，也称为ZUC算法，是一种由中国学者自主设计的同步序列密码算法（流密码），主要用于加密和数据完整性校验。它是中国第一个成为国际密码标准的算法，被采纳为4G移动通信系统（LTE）的国际标准...</code></p>
<p>以下是GB/T33133.1—2016标准中的算法结构图：</p>
<p><img src="https://golden-forest.top/dc084f0926201d44aa4cc4c134c743a1.png" alt="" /></p>
<p>现在看不懂还很正常，下面我们会<strong>结合代码一层层</strong>地解释。简单来说，<strong>ZUC算法是一种可以用于生成 <code>流密钥</code>的算法，用于 <code>流密码</code>加密，其核心有三个步骤</strong></p>
<ul>
<li>比特重组(BR)</li>
<li>非线性函数F(F)</li>
<li>线性反馈移位寄存器(LFSR)</li>
</ul>
<p>代码实现上，还需考虑预处理一下输入</p>
<ul>
<li>预处理</li>
</ul>
<p>而得到的 <code>流密钥</code>用于加密解密只需要简单异或一下就行了</p>
<ul>
<li>加密解密</li>
</ul>
<p>综上，本文将分为以上5部分去尽可能完整且详细地介绍ZUC算法</p>
<p><strong>PS：本文将以递进式的方式去介绍，而不是分块式，建议跟着一步步看，不然容易出现思维跳跃</strong></p>
<p>（以下是程序源码：）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line">############## ZUC密钥生成算法实现 ##############</span><br><span class="line">class ZUCAlgorithm:</span><br><span class="line"></span><br><span class="line">    def __init__(self, key, iv):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化ZUC算法</span><br><span class="line">        :param key: 128位初始密钥 (16字节)</span><br><span class="line">        :param iv: 128位初始向量 (16字节)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(&quot;=== ZUC算法初始化开始 ===&quot;)</span><br><span class="line">  </span><br><span class="line">        # LFSR: 16个31位寄存器</span><br><span class="line">        self.LFSR = [0] * 16</span><br><span class="line">  </span><br><span class="line">        # 非线性函数F的记忆单元</span><br><span class="line">        self.R1 = 0</span><br><span class="line">        self.R2 = 0</span><br><span class="line">  </span><br><span class="line">        self.key = key</span><br><span class="line">        self.iv = iv</span><br><span class="line">  </span><br><span class="line">        print(f&quot;密钥: &#123;key.hex()&#125;&quot;)</span><br><span class="line">        print(f&quot;初始向量: &#123;iv.hex()&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">        # 初始化常量</span><br><span class="line">        self.d = self._init_d_constants()</span><br><span class="line">        self.sbox = ZUCSBox()</span><br><span class="line">  </span><br><span class="line">        print(&quot;=== ZUC算法初始化完成 ===\n&quot;)</span><br><span class="line">  </span><br><span class="line">    def _init_d_constants(self):</span><br><span class="line">        &quot;&quot;&quot;初始化15位常量d_i&quot;&quot;&quot;</span><br><span class="line">        print(&quot;步骤: 初始化15位常量d_i&quot;)</span><br><span class="line">        d_values = [</span><br><span class="line">            0b100010011010111, 0b010011010111100, 0b110001001101011,</span><br><span class="line">            0b001001101011110, 0b101011110001001, 0b011010111100010,</span><br><span class="line">            0b111000100110101, 0b000100110101111, 0b100110101111000,</span><br><span class="line">            0b010111100010011, 0b110101111000100, 0b001101011110001,</span><br><span class="line">            0b101111000100110, 0b011110001001101, 0b111100010011010,</span><br><span class="line">            0b100011110101100</span><br><span class="line">        ]</span><br><span class="line">        return d_values</span><br><span class="line">  </span><br><span class="line">    def key_load(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        将初始密钥k和初始向量iv装入到LFSR的寄存器单元变量中</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(&quot;=== 密钥装入过程开始 ===&quot;)</span><br><span class="line">  </span><br><span class="line">        for i in range(16): # ①确保每个寄存器都包含了密钥、固定值和初始向量的信息</span><br><span class="line">            # 提取密钥和初始向量的字节</span><br><span class="line">            k_byte = self.key[i]</span><br><span class="line">            iv_byte = self.iv[i]</span><br><span class="line">  </span><br><span class="line">            # s_i = k_i || d_i || iv_i</span><br><span class="line">            # k_i: 8位, d_i: 15位, iv_i: 8位</span><br><span class="line">            self.LFSR[i] = (k_byte &lt;&lt; 23) | (self.d[i] &lt;&lt; 8) | iv_byte</span><br><span class="line">  </span><br><span class="line">            print(f&quot;LFSR[&#123;i&#125;] = &#123;self.LFSR[i]:08x&#125; (k=&#123;k_byte:02x&#125;, d=&#123;self.d[i]:04x&#125;, iv=&#123;iv_byte:02x&#125;)&quot;)</span><br><span class="line">  </span><br><span class="line">        print(&quot;=== 密钥装入过程完成 ===\n&quot;)</span><br><span class="line">  </span><br><span class="line">    def mod_231_1_add(self, a, b):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        模2^31-1加法实现</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        result = a + b</span><br><span class="line">        result = (result &amp; 0x7FFFFFFF) + (result &gt;&gt; 31)</span><br><span class="line">        return result</span><br><span class="line">  </span><br><span class="line">    def mod_231_1_mult(self, a, b):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        模2^31-1乘法实现</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return (a * b) % (2**31 - 1)</span><br><span class="line">  </span><br><span class="line">    def lfsr_initialization_mode(self, u):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        LFSR接收1个31比特字u的输入，更新寄存器</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # (1) 计算v</span><br><span class="line">        v = self.mod_231_1_mult(2**15, self.LFSR[15])</span><br><span class="line">        v = self.mod_231_1_add(v, self.mod_231_1_mult(2**17, self.LFSR[13]))</span><br><span class="line">        v = self.mod_231_1_add(v, self.mod_231_1_mult(2**21, self.LFSR[10]))</span><br><span class="line">        v = self.mod_231_1_add(v, self.mod_231_1_mult(2**20, self.LFSR[4]))</span><br><span class="line">        v = self.mod_231_1_add(v, self.mod_231_1_mult((1 + 2**8), self.LFSR[0]))</span><br><span class="line">  </span><br><span class="line">        # (2) 计算s16</span><br><span class="line">        s16 = self.mod_231_1_add(v, u)</span><br><span class="line">  </span><br><span class="line">        # (3) 如果s16=0，则置s16=2^31-1</span><br><span class="line">        if s16 == 0:</span><br><span class="line">            s16 = 2**31 - 1</span><br><span class="line">  </span><br><span class="line">        # (4) 移位操作</span><br><span class="line">        for i in range(15):</span><br><span class="line">            self.LFSR[i] = self.LFSR[i + 1]</span><br><span class="line">        self.LFSR[15] = s16</span><br><span class="line">  </span><br><span class="line">        return s16</span><br><span class="line">  </span><br><span class="line">    def lfsr_work_mode(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        LFSR工作模式</span><br><span class="line">        LFSR无输入，直接更新寄存器</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # (1) 计算s16</span><br><span class="line">        s16 = self.mod_231_1_mult(2**15, self.LFSR[15])</span><br><span class="line">        s16 = self.mod_231_1_add(s16, self.mod_231_1_mult(2**17, self.LFSR[13]))</span><br><span class="line">        s16 = self.mod_231_1_add(s16, self.mod_231_1_mult(2**21, self.LFSR[10]))</span><br><span class="line">        s16 = self.mod_231_1_add(s16, self.mod_231_1_mult(2**20, self.LFSR[4]))</span><br><span class="line">        s16 = self.mod_231_1_add(s16, self.mod_231_1_mult((1 + 2**8), self.LFSR[0]))</span><br><span class="line">  </span><br><span class="line">        # (2) 如果s16=0，则置s16=2^31-1</span><br><span class="line">        if s16 == 0:</span><br><span class="line">            s16 = 2**31 - 1</span><br><span class="line">  </span><br><span class="line">        # (3) 移位操作</span><br><span class="line">        for i in range(15):</span><br><span class="line">            self.LFSR[i] = self.LFSR[i + 1]</span><br><span class="line">        self.LFSR[15] = s16</span><br><span class="line">  </span><br><span class="line">        return s16</span><br><span class="line">  </span><br><span class="line">    def bit_reconstruction(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        比特重组(BR)</span><br><span class="line">        从LFSR寄存器中重组4个32位字X0, X1, X2, X3</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 提取LFSR寄存器的高16位和低16位</span><br><span class="line">        s15H = (self.LFSR[15] &gt;&gt; 15) &amp; 0xFFFF  # s15的高16位</span><br><span class="line">        s14L = self.LFSR[14] &amp; 0x7FFF          # s14的低15位</span><br><span class="line">        s11H = (self.LFSR[11] &gt;&gt; 15) &amp; 0xFFFF  # s11的高16位</span><br><span class="line">        s9L = self.LFSR[9] &amp; 0x7FFF            # s9的低15位</span><br><span class="line">        s7H = (self.LFSR[7] &gt;&gt; 15) &amp; 0xFFFF    # s7的高16位</span><br><span class="line">        s5L = self.LFSR[5] &amp; 0x7FFF            # s5的低15位</span><br><span class="line">        s2H = (self.LFSR[2] &gt;&gt; 15) &amp; 0xFFFF    # s2的高16位</span><br><span class="line">        s0L = self.LFSR[0] &amp; 0x7FFF            # s0的低15位</span><br><span class="line">  </span><br><span class="line">        # 重组32位字</span><br><span class="line">        X0 = (s15H &lt;&lt; 16) | s14L</span><br><span class="line">        X1 = (s11H &lt;&lt; 16) | s9L</span><br><span class="line">        X2 = (s7H &lt;&lt; 16) | s5L</span><br><span class="line">        X3 = (s2H &lt;&lt; 16) | s0L</span><br><span class="line">  </span><br><span class="line">        return X0, X1, X2, X3</span><br><span class="line">  </span><br><span class="line">    def linear_transform_L1(self, X):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        线性变换L1</span><br><span class="line">        L1(X) = X ⊕ (X &lt;&lt;&lt; 2) ⊕ (X &lt;&lt;&lt; 10) ⊕ (X &lt;&lt;&lt; 18) ⊕ (X &lt;&lt;&lt; 24)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        def rotate_left_32(x, n):</span><br><span class="line">            &quot;&quot;&quot;32位循环左移&quot;&quot;&quot;</span><br><span class="line">            return ((x &lt;&lt; n) | (x &gt;&gt; (32 - n))) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">        result = X</span><br><span class="line">        result ^= rotate_left_32(X, 2)</span><br><span class="line">        result ^= rotate_left_32(X, 10)</span><br><span class="line">        result ^= rotate_left_32(X, 18)</span><br><span class="line">        result ^= rotate_left_32(X, 24)</span><br><span class="line">  </span><br><span class="line">        return result &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">    def linear_transform_L2(self, X):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        线性变换L2</span><br><span class="line">        L2(X) = X ⊕ (X &lt;&lt;&lt; 8) ⊕ (X &lt;&lt;&lt; 14) ⊕ (X &lt;&lt;&lt; 22) ⊕ (X &lt;&lt;&lt; 30)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        def rotate_left_32(x, n):</span><br><span class="line">            &quot;&quot;&quot;32位循环左移&quot;&quot;&quot;</span><br><span class="line">            return ((x &lt;&lt; n) | (x &gt;&gt; (32 - n))) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">        result = X</span><br><span class="line">        result ^= rotate_left_32(X, 8)</span><br><span class="line">        result ^= rotate_left_32(X, 14)</span><br><span class="line">        result ^= rotate_left_32(X, 22)</span><br><span class="line">        result ^= rotate_left_32(X, 30)</span><br><span class="line">  </span><br><span class="line">        return result &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">    def nonlinear_function_F(self, X0, X1, X2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        非线性函数F</span><br><span class="line">        输入: X0, X1, X2 (32位字)</span><br><span class="line">        输出: W (32位字)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # (1) W = (X0 ⊕ R1) + R2 mod 2^32</span><br><span class="line">        W = ((X0 ^ self.R1) + self.R2) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">        # (2) W1 = R1 + X1 mod 2^32</span><br><span class="line">        W1 = (self.R1 + X1) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">        # (3) W2 = R2 ⊕ X2</span><br><span class="line">        W2 = self.R2 ^ X2</span><br><span class="line">  </span><br><span class="line">        # (4) R1 = S[L1(W1H || W2L)]</span><br><span class="line">        W1H = (W1 &gt;&gt; 16) &amp; 0xFFFF  # W1的高16位</span><br><span class="line">        W2L = W2 &amp; 0xFFFF          # W2的低16位</span><br><span class="line">        R1_input = (W1H &lt;&lt; 16) | W2L</span><br><span class="line">        self.R1 = self.sbox.sbox_32(self.linear_transform_L1(R1_input))</span><br><span class="line">  </span><br><span class="line">        # (5) R2 = S[L2(W2H || W1L)]</span><br><span class="line">        W2H = (W2 &gt;&gt; 16) &amp; 0xFFFF  # W2的高16位</span><br><span class="line">        W1L = W1 &amp; 0xFFFF          # W1的低16位</span><br><span class="line">        R2_input = (W2H &lt;&lt; 16) | W1L</span><br><span class="line">        self.R2 = self.sbox.sbox_32(self.linear_transform_L2(R2_input))</span><br><span class="line">  </span><br><span class="line">        return W</span><br><span class="line">  </span><br><span class="line">    def initialization_phase(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化步骤</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(&quot;=== 初始化步骤开始 ===&quot;)</span><br><span class="line">  </span><br><span class="line">        # (a) 密钥装入</span><br><span class="line">        print(&quot;步骤(a): 密钥装入&quot;)</span><br><span class="line">        self.key_load()</span><br><span class="line">  </span><br><span class="line">        # (b) 初始化R1和R2为0</span><br><span class="line">        print(&quot;步骤(b): 初始化R1和R2为0&quot;)</span><br><span class="line">        self.R1 = 0</span><br><span class="line">        self.R2 = 0</span><br><span class="line">  </span><br><span class="line">        # (c) 重复执行32次</span><br><span class="line">        print(&quot;步骤(c): 执行32轮初始化&quot;)</span><br><span class="line">        for i in range(32):</span><br><span class="line">            print(f&quot;  第&#123;i+1&#125;轮初始化:&quot;)</span><br><span class="line">  </span><br><span class="line">            # 1) 比特重组</span><br><span class="line">            X0, X1, X2, X3 = self.bit_reconstruction()</span><br><span class="line">            print(f&quot;    比特重组: X0=&#123;X0:08x&#125;, X1=&#123;X1:08x&#125;, X2=&#123;X2:08x&#125;, X3=&#123;X3:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">            # 2) 非线性函数F</span><br><span class="line">            W = self.nonlinear_function_F(X0, X1, X2)</span><br><span class="line">            print(f&quot;    非线性函数F: W=&#123;W:08x&#125;, R1=&#123;self.R1:08x&#125;, R2=&#123;self.R2:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">            # 3) 输出W (在初始化阶段通常不输出)</span><br><span class="line">  </span><br><span class="line">            # 4) LFSR初始化模式，输入W&gt;&gt;1 (取31位)</span><br><span class="line">            u = W &gt;&gt; 1</span><br><span class="line">            self.lfsr_initialization_mode(u)</span><br><span class="line">            print(f&quot;    LFSR更新: u=&#123;u:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">        print(&quot;=== 初始化步骤完成 ===\n&quot;)</span><br><span class="line">  </span><br><span class="line">    def generate_keystream(self, L):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        工作步骤</span><br><span class="line">        生成L个32位密钥字</span><br><span class="line">        :param L: 需要生成的密钥字数量</span><br><span class="line">        :return: 密钥字列表</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(&quot;=== 工作步骤开始 ===&quot;)</span><br><span class="line">        print(f&quot;目标: 生成&#123;L&#125;个32位密钥字&quot;)</span><br><span class="line">  </span><br><span class="line">        keystream = []</span><br><span class="line">  </span><br><span class="line">        print(&quot;步骤(a): 工作阶段初始化&quot;)</span><br><span class="line">        X0, X1, X2, X3 = self.bit_reconstruction()</span><br><span class="line">        print(f&quot;  比特重组: X0=&#123;X0:08x&#125;, X1=&#123;X1:08x&#125;, X2=&#123;X2:08x&#125;, X3=&#123;X3:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">        self.nonlinear_function_F(X0, X1, X2)</span><br><span class="line">        print(f&quot;  非线性函数F: R1=&#123;self.R1:08x&#125;, R2=&#123;self.R2:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">        self.lfsr_work_mode()</span><br><span class="line">        print(&quot;  LFSR工作模式更新完成&quot;)</span><br><span class="line">  </span><br><span class="line">        # (b) 重复计算L次</span><br><span class="line">        print(f&quot;步骤(b): 生成&#123;L&#125;个密钥字&quot;)</span><br><span class="line">        for i in range(L):</span><br><span class="line">            print(f&quot;  第&#123;i+1&#125;个密钥字生成:&quot;)</span><br><span class="line">  </span><br><span class="line">            # 1) 比特重组</span><br><span class="line">            X0, X1, X2, X3 = self.bit_reconstruction()</span><br><span class="line">            print(f&quot;    比特重组: X0=&#123;X0:08x&#125;, X1=&#123;X1:08x&#125;, X2=&#123;X2:08x&#125;, X3=&#123;X3:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">            # 2) Z = F(X0,X1,X2) ⊕ X3</span><br><span class="line">            F_output = self.nonlinear_function_F(X0, X1, X2)</span><br><span class="line">            Z = F_output ^ X3</span><br><span class="line">            print(f&quot;    密钥字计算: F=&#123;F_output:08x&#125;, Z=F⊕X3=&#123;Z:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">            # 3) 输出密钥字Z</span><br><span class="line">            keystream.append(Z)</span><br><span class="line">  </span><br><span class="line">            # 4) LFSR工作模式</span><br><span class="line">            self.lfsr_work_mode()</span><br><span class="line">            print(f&quot;    LFSR工作模式更新完成&quot;)</span><br><span class="line">  </span><br><span class="line">        print(&quot;=== 工作步骤完成 ===\n&quot;)</span><br><span class="line">        return keystream</span><br><span class="line"></span><br><span class="line">############## Sbox初始化 ##############</span><br><span class="line">class ZUCSBox:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    ZUC算法S盒实现</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;初始化ZUC S盒...&quot;)</span><br><span class="line">        self.S0 = self._create_s0()</span><br><span class="line">        self.S1 = self._create_s1()</span><br><span class="line">  </span><br><span class="line">    def _create_s0(self):</span><br><span class="line">        &quot;&quot;&quot;创建S0盒的一维查找表&quot;&quot;&quot;</span><br><span class="line">        S0_table = [</span><br><span class="line">            [0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54, 0x98, 0x09, 0xB9, 0x6D, 0xCB],</span><br><span class="line">            [0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D, 0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90],</span><br><span class="line">            [0x4D, 0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48, 0x8B, 0x29, 0x6E, 0xAC],</span><br><span class="line">            [0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69, 0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38],</span><br><span class="line">            [0x76, 0x7D, 0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21, 0x06, 0x55, 0x9B],</span><br><span class="line">            [0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4, 0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C],</span><br><span class="line">            [0x4A, 0x16, 0xD5, 0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01, 0xD3, 0xAD],</span><br><span class="line">            [0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F, 0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8],</span><br><span class="line">            [0xB1, 0xB4, 0x37, 0xF7, 0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96, 0x56],</span><br><span class="line">            [0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE],</span><br><span class="line">            [0xBC, 0x26, 0x95, 0x88, 0x8A, 0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D],</span><br><span class="line">            [0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12, 0xF5, 0x74, 0x9C, 0xAA, 0x23],</span><br><span class="line">            [0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02, 0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1],</span><br><span class="line">            [0xF6, 0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6, 0x40, 0xC4, 0xE2, 0x0F],</span><br><span class="line">            [0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F, 0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65],</span><br><span class="line">            [0x8D, 0x27, 0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE, 0x78, 0x34, 0x60]</span><br><span class="line">        ]</span><br><span class="line">  </span><br><span class="line">        s0_1d = [0] * 256</span><br><span class="line">        for i in range(16):</span><br><span class="line">            for j in range(16):</span><br><span class="line">                s0_1d[i * 16 + j] = S0_table[i][j]</span><br><span class="line">        return s0_1d</span><br><span class="line">  </span><br><span class="line">    def _create_s1(self):</span><br><span class="line">        &quot;&quot;&quot;创建S1盒的一维查找表&quot;&quot;&quot;</span><br><span class="line">        S1_table = [</span><br><span class="line">            [0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA, 0x5B, 0x29, 0xAA, 0xFD, 0x77],</span><br><span class="line">            [0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A, 0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42],</span><br><span class="line">            [0x44, 0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7, 0x8B, 0x39, 0x43, 0xE1],</span><br><span class="line">            [0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3, 0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48],</span><br><span class="line">            [0xDD, 0x20, 0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69, 0xF5, 0xD4, 0x87],</span><br><span class="line">            [0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC, 0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB],</span><br><span class="line">            [0x2B, 0x53, 0xD8, 0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73, 0x08, 0x09],</span><br><span class="line">            [0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E, 0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9],</span><br><span class="line">            [0xAD, 0xF1, 0xAE, 0x2E, 0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1, 0xE9],</span><br><span class="line">            [0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D, 0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89],</span><br><span class="line">            [0x01, 0xB6, 0xBD, 0x58, 0x24, 0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4],</span><br><span class="line">            [0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0, 0x02, 0x4A, 0x79, 0xC3, 0xDE],</span><br><span class="line">            [0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B, 0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21],</span><br><span class="line">            [0x5A, 0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A, 0xBA, 0x7E, 0x0E, 0x34],</span><br><span class="line">            [0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60, 0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28],</span><br><span class="line">            [0x64, 0xBE, 0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12, 0x03, 0xE2, 0xF2]</span><br><span class="line">        ]</span><br><span class="line">  </span><br><span class="line">        s1_1d = [0] * 256</span><br><span class="line">        for i in range(16):</span><br><span class="line">            for j in range(16):</span><br><span class="line">                s1_1d[i * 16 + j] = S1_table[i][j]</span><br><span class="line">        return s1_1d</span><br><span class="line">  </span><br><span class="line">    def sbox_32(self, X):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        32位S盒变换</span><br><span class="line">        :param X: 32位输入</span><br><span class="line">        :return: 32位输出</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 将32位输入分解为4个8位字节</span><br><span class="line">        x0 = (X &gt;&gt; 24) &amp; 0xFF</span><br><span class="line">        x1 = (X &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">        x2 = (X &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">        x3 = X &amp; 0xFF</span><br><span class="line">  </span><br><span class="line">        # 分别应用S盒</span><br><span class="line">        y0 = self.S0[x0]</span><br><span class="line">        y1 = self.S1[x1]</span><br><span class="line">        y2 = self.S0[x2]  # S2 = S0</span><br><span class="line">        y3 = self.S1[x3]  # S3 = S1</span><br><span class="line">  </span><br><span class="line">        # 重新组合为32位输出</span><br><span class="line">        Y = (y0 &lt;&lt; 24) | (y1 &lt;&lt; 16) | (y2 &lt;&lt; 8) | y3</span><br><span class="line">        return Y</span><br><span class="line"></span><br><span class="line">############## 使用ZUC生成的密钥流加密 ##############</span><br><span class="line">def zuc_encrypt(key, iv, data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用ZUC算法加密数据</span><br><span class="line">    :param key: 128位密钥 (16字节)</span><br><span class="line">    :param iv: 128位初始向量 (16字节)</span><br><span class="line">    :param data: 要加密的数据 (字节串)</span><br><span class="line">    :return: 加密后的数据 (字节串)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&quot;=== ZUC加密开始 ===&quot;)</span><br><span class="line">  </span><br><span class="line">    # 初始化ZUC算法</span><br><span class="line">    zuc = ZUCAlgorithm(key, iv)</span><br><span class="line">  </span><br><span class="line">    # 执行初始化阶段</span><br><span class="line">    zuc.initialization_phase()</span><br><span class="line">  </span><br><span class="line">    # 计算需要的密钥字数量</span><br><span class="line">    data_len = len(data)</span><br><span class="line">    key_words_needed = (data_len + 3) // 4  # 每个密钥字对应4字节数据</span><br><span class="line">  </span><br><span class="line">    # 生成密钥流</span><br><span class="line">    keystream = zuc.generate_keystream(key_words_needed)</span><br><span class="line">  </span><br><span class="line">    # 将密钥流转换为字节流</span><br><span class="line">    keystream_bytes = bytearray()</span><br><span class="line">    for word in keystream:</span><br><span class="line">        keystream_bytes.extend([</span><br><span class="line">            (word &gt;&gt; 24) &amp; 0xFF,</span><br><span class="line">            (word &gt;&gt; 16) &amp; 0xFF,</span><br><span class="line">            (word &gt;&gt; 8) &amp; 0xFF,</span><br><span class="line">            word &amp; 0xFF</span><br><span class="line">        ])</span><br><span class="line">  </span><br><span class="line">    # 将数据与密钥流异或</span><br><span class="line">    encrypted = bytearray()</span><br><span class="line">    for i in range(data_len):</span><br><span class="line">        encrypted.append(data[i] ^ keystream_bytes[i])</span><br><span class="line">  </span><br><span class="line">    print(f&quot;加密完成: &#123;len(data)&#125;字节&quot;)</span><br><span class="line">    print(&quot;=== ZUC加密结束 ===\n&quot;)</span><br><span class="line">  </span><br><span class="line">    return bytes(encrypted)</span><br><span class="line"></span><br><span class="line">############## 使用ZUC解密生成的密钥流加密 ##############</span><br><span class="line">def zuc_decrypt(key, iv, encrypted_data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用ZUC算法解密数据</span><br><span class="line">    ZUC是对称算法，解密与加密过程相同 （对称加密）</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return zuc_encrypt(key, iv, encrypted_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># main()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(&quot;ZUC算法测试&quot;)</span><br><span class="line"></span><br><span class="line">    key = bytes([0x00] * 16)</span><br><span class="line">    iv = bytes([0x00] * 16)</span><br><span class="line">    data = b&quot;Hello, ZUC Algorithm!&quot;</span><br><span class="line">  </span><br><span class="line">    print(&quot;测试: 全0密钥和初始向量&quot;)</span><br><span class="line">    encrypted = zuc_encrypt(key, iv, data)</span><br><span class="line">    decrypted = zuc_decrypt(key, iv, encrypted)</span><br><span class="line">  </span><br><span class="line">    print(f&quot;原始数据: &#123;data&#125;&quot;)</span><br><span class="line">    print(f&quot;加密数据: &#123;encrypted.hex()&#125;&quot;)</span><br><span class="line">    print(f&quot;解密数据: &#123;decrypted&#125;&quot;)</span><br><span class="line">    print(f&quot;加解密成功: &#123;data == decrypted&#125;\n&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="预处理"><a class="markdownIt-Anchor" href="#预处理"></a> 预处理</h2>
<p>在开始介绍算法之前，先来我们传入的参数是什么意思：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key = bytes([0x00] * 16)	# 密钥</span><br><span class="line">iv = bytes([0x00] * 16)	# 向量</span><br><span class="line">data = b&quot;Hello, ZUC Algorithm!&quot; # 待加密的内容</span><br></pre></td></tr></table></figure>
<ul>
<li>密钥：128位（也就是16字节）。核心参数，<strong>决定了加密系统的根本安全性</strong>。因为其从根本上决定了伪随机密钥流的“基座”或“种子模式”。不同的密钥会产生完全不同的、不相关的密钥流序列。<strong>需要严格保密</strong></li>
<li>IV（向量）：128位（也就是16字节）。密码学中存在一种 <code>重放攻击</code>（作者不懂，不过多介绍），而引入 <code>向量</code>可以确保密钥流的随机性与唯一性，防止 <code>重放攻击</code>。通常不需要保密，<strong>因为每次加密都应该引入一个完全不同、唯一的向量</strong></li>
</ul>
<p>IV（向量）与密钥协同工作，为每次加密都会生成一个独一无二的起始点。<strong>即使用相同的密钥，只要IV（向量）不同，ZUC算法产生的密钥流就会完全不同</strong>。这确保了即使加密了两段完全相同的明文，得到的密文也会截然不同。</p>
<ul>
<li>待加密的内容：可以是任意、随机、完全无限制的一段数据。ZUC是一种流密钥，意味着生成的一个个bit的 <code>流密钥</code>，我们只需要生成与待加密数据对应长度的密钥字即可进行加密。</li>
</ul>
<p>了解了这些以后，我们来看我们代码的主函数，在python中也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># main()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(&quot;ZUC算法测试&quot;)</span><br><span class="line"></span><br><span class="line">    key = bytes([0x00] * 16)</span><br><span class="line">    iv = bytes([0x00] * 16)</span><br><span class="line">    data = b&quot;Hello, ZUC Algorithm!&quot;</span><br><span class="line">  </span><br><span class="line">    print(&quot;测试: 全0密钥和初始向量&quot;)</span><br><span class="line">    encrypted = zuc_encrypt(key, iv, data)</span><br><span class="line">    decrypted = zuc_decrypt(key, iv, encrypted)</span><br><span class="line">  </span><br><span class="line">    print(f&quot;原始数据: &#123;data&#125;&quot;)</span><br><span class="line">    print(f&quot;加密数据: &#123;encrypted.hex()&#125;&quot;)</span><br><span class="line">    print(f&quot;解密数据: &#123;decrypted&#125;&quot;)</span><br><span class="line">    print(f&quot;加解密成功: &#123;data == decrypted&#125;\n&quot;)</span><br></pre></td></tr></table></figure>
<p>那么我们直接来看ZUC的加密函数：<code>zuc_encrypt(key, iv, data)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">（）def zuc_encrypt(key, iv, data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param key: 128位密钥 (16字节)</span><br><span class="line">    :param iv: 128位初始向量 (16字节)</span><br><span class="line">    :param data: 要加密的数据 (字节串)</span><br><span class="line">    :return: 加密后的数据 (字节串)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&quot;=== ZUC加密开始 ===&quot;)</span><br><span class="line">  </span><br><span class="line">    # 初始化ZUC算法</span><br><span class="line">    zuc = ZUCAlgorithm(key, iv)</span><br><span class="line">  </span><br><span class="line">    # 执行初始阶段（我更喜欢称之为预热阶段）</span><br><span class="line">    zuc.initialization_phase()</span><br><span class="line">  </span><br><span class="line">    # 计算需要的密钥字数量</span><br><span class="line">    data_len = len(data)</span><br><span class="line">    key_words_needed = (data_len + 3) // 4  # 每个密钥字对应4字节数据</span><br><span class="line">  </span><br><span class="line">    # 生成密钥流</span><br><span class="line">    keystream = zuc.generate_keystream(key_words_needed)</span><br><span class="line">  </span><br><span class="line">    # 将密钥流转换为字节流</span><br><span class="line">    keystream_bytes = bytearray()</span><br><span class="line">    for word in keystream:</span><br><span class="line">        keystream_bytes.extend([</span><br><span class="line">            (word &gt;&gt; 24) &amp; 0xFF,</span><br><span class="line">            (word &gt;&gt; 16) &amp; 0xFF,</span><br><span class="line">            (word &gt;&gt; 8) &amp; 0xFF,</span><br><span class="line">            word &amp; 0xFF</span><br><span class="line">        ])</span><br><span class="line">  </span><br><span class="line">    # 将数据与密钥流异或</span><br><span class="line">    encrypted = bytearray()</span><br><span class="line">    for i in range(data_len):</span><br><span class="line">        encrypted.append(data[i] ^ keystream_bytes[i])</span><br><span class="line">  </span><br><span class="line">    print(f&quot;加密完成: &#123;len(data)&#125;字节&quot;)</span><br><span class="line">    print(&quot;=== ZUC加密结束 ===\n&quot;)</span><br><span class="line">  </span><br><span class="line">    return bytes(encrypted)</span><br></pre></td></tr></table></figure>
<p>可以看到，整个加密函数一共分为这几步：</p>
<ul>
<li>①将我们提供的参数，也就是<strong>将key、IV传入一个初始化函数</strong></li>
<li>②<strong>加载算法的起步阶段函数</strong>，但是我更喜欢称其为“预热”阶段</li>
<li>③计算所需的密钥字数量，生成密钥流，<strong>也就是启动ZUC算法的工作模式</strong></li>
<li>④最后将密钥流转换为字节流（其实也就是需要和数据的格式一致），将数据与密钥流异或，完成加密</li>
</ul>
<p>其中前三部是我们要关注的重点，也就是密钥流是如何来的，最后的异或其实无关紧要</p>
<p>我们来一步步看下去</p>
<h3 id="传参"><a class="markdownIt-Anchor" href="#传参"></a> 传参</h3>
<p>先来看我们的key和iv被用来干什么了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class ZUCAlgorithm:</span><br><span class="line"></span><br><span class="line">    def __init__(self, key, iv):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param key: 128位初始密钥 (16字节)</span><br><span class="line">        :param iv: 128位初始向量 (16字节)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(&quot;=== ZUC算法初始化开始 ===&quot;)</span><br><span class="line">  </span><br><span class="line">        # LFSR: 16个31位寄存器  </span><br><span class="line">        self.LFSR = [0] * 16	# 可以先不管</span><br><span class="line">  </span><br><span class="line">        # 非线性函数F的记忆单元</span><br><span class="line">        self.R1 = 0</span><br><span class="line">        self.R2 = 0</span><br><span class="line">  </span><br><span class="line">        self.key = key</span><br><span class="line">        self.iv = iv</span><br><span class="line">  </span><br><span class="line">        print(f&quot;密钥: &#123;key.hex()&#125;&quot;)</span><br><span class="line">        print(f&quot;初始向量: &#123;iv.hex()&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">        # 初始化常量</span><br><span class="line">        self.d = self._init_d_constants()</span><br><span class="line">        self.sbox = ZUCSBox()</span><br><span class="line">  </span><br><span class="line">        print(&quot;=== ZUC算法初始化完成 ===\n&quot;)</span><br><span class="line">################## 下面的代码与接下来要展示的东西无关 ################</span><br></pre></td></tr></table></figure>
<p>调用这个类会触发构造函数（<code>__init__ </code>魔术方法），其主要干了这么几件事：</p>
<ul>
<li>将key、iv传给类成员 ：<code>self.key = key</code>  、<code>self.iv = iv</code></li>
<li>将R1、R2置零（先不管，后面介绍）</li>
<li><strong>声明LFSR的16个31位寄存器</strong>，以数组实现（先不管，后面介绍）</li>
<li>调用了 <code>_init_d_constants()</code>、<code>ZUCSBox()</code>初始化（照样先不管，马上就知道用来干什么）</li>
</ul>
<p>都是些初始化，由于其中参数我们很多都不认识，所以先不管</p>
<p>这里展示的主要原因是留个印象，接下来我们会一一介绍</p>
<p>接下来我们返回上一层，来看预热函数：<code>initialization_phase()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def initialization_phase(self):</span><br><span class="line"></span><br><span class="line">        print(&quot;=== 初始化步骤开始 ===&quot;)</span><br><span class="line">  </span><br><span class="line">        # (a) 密钥装入</span><br><span class="line">        print(&quot;步骤(a): 密钥装入&quot;)</span><br><span class="line">        self.key_load()</span><br><span class="line">  </span><br><span class="line">        # (b) 初始化R1和R2为0</span><br><span class="line">        print(&quot;步骤(b): 初始化R1和R2为0&quot;)</span><br><span class="line">        self.R1 = 0</span><br><span class="line">        self.R2 = 0</span><br><span class="line">  </span><br><span class="line">        # (c) 重复执行32次</span><br><span class="line">        print(&quot;步骤(c): 执行32轮初始化&quot;)</span><br><span class="line">        for i in range(32):</span><br><span class="line">            print(f&quot;  第&#123;i+1&#125;轮初始化:&quot;)</span><br><span class="line">  </span><br><span class="line">            # 1) 比特重组</span><br><span class="line">            X0, X1, X2, X3 = self.bit_reconstruction()</span><br><span class="line">            print(f&quot;    比特重组: X0=&#123;X0:08x&#125;, X1=&#123;X1:08x&#125;, X2=&#123;X2:08x&#125;, X3=&#123;X3:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">            # 2) 非线性函数F</span><br><span class="line">            W = self.nonlinear_function_F(X0, X1, X2)</span><br><span class="line">            print(f&quot;    非线性函数F: W=&#123;W:08x&#125;, R1=&#123;self.R1:08x&#125;, R2=&#123;self.R2:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">            # 3) 输出W (在初始化阶段通常不输出)</span><br><span class="line">  </span><br><span class="line">            # 4) LFSR初始化模式，输入W&gt;&gt;1 (取31位)</span><br><span class="line">            u = W &gt;&gt; 1</span><br><span class="line">            self.lfsr_initialization_mode(u)</span><br><span class="line">            print(f&quot;    LFSR更新: u=&#123;u:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">        print(&quot;=== 初始化步骤完成 ===\n&quot;)</span><br></pre></td></tr></table></figure>
<p>接着我们来看预处理阶段最重要的<strong>密钥装入</strong>部分，在算法标准结构图中，<strong>也就是将原本空的s0-s15装入内容</strong>：</p>
<p><img src="https://golden-forest.top/de53110763e7658bc09c79a704b4df5c.png" alt="" /></p>
<h3 id="密钥装入"><a class="markdownIt-Anchor" href="#密钥装入"></a> 密钥装入</h3>
<p>先贴代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def key_load(self):</span><br><span class="line"></span><br><span class="line">    print(&quot;=== 密钥装入过程开始 ===&quot;)</span><br><span class="line">  </span><br><span class="line">    for i in range(16): # ①确保每个寄存器都包含了密钥、固定值和初始向量的信息</span><br><span class="line">        # 提取密钥和初始向量的字节</span><br><span class="line">        k_byte = self.key[i]</span><br><span class="line">        iv_byte = self.iv[i]</span><br><span class="line">  </span><br><span class="line">        # s_i = k_i || d_i || iv_i</span><br><span class="line">        # k_i: 8位, d_i: 15位, iv_i: 8位</span><br><span class="line">        self.LFSR[i] = (k_byte &lt;&lt; 23) | (self.d[i] &lt;&lt; 8) | iv_byte</span><br><span class="line">  </span><br><span class="line">        print(f&quot;LFSR[&#123;i&#125;] = &#123;self.LFSR[i]:08x&#125; (k=&#123;k_byte:02x&#125;, d=&#123;self.d[i]:04x&#125;, iv=&#123;iv_byte:02x&#125;)&quot;)</span><br><span class="line">  </span><br><span class="line">    print(&quot;=== 密钥装入过程完成 ===\n&quot;)</span><br></pre></td></tr></table></figure>
<p>这里指的<strong>密钥装入，事实上指的是将key + iv 配合用于初始化 <code>LFSR</code>的16个寄存器，即s0-s15</strong></p>
<p>简单介绍以下 <code>LFSR</code>是什么：<code>全程“线性反馈移位寄存器”，一个会进行移位的寄存器，其输入由自身获得，可以产生“伪随机（最大周期是 2^n - 1）”的输出序列，密码学中它的作用是快速产生一个长周期的伪随机密钥流</code></p>
<p>具体 <code>LFSR</code>我们下面会介绍，这里要讲的是这段代码是如何将我们的key + iv装入这16个寄存器的：</p>
<ul>
<li>进行16轮操作，每轮操作如下：</li>
<li>①遍历，从key和iv提取一个字节，分别记作k_i、iv_i</li>
<li>②第i个寄存器记作s_i</li>
<li>③将s_i 赋值为 ：k_i的后8位 +  d_i的后15位（先别急马上介绍）+ iv_i的8位</li>
<li>④这样子每个s_i就是31位了</li>
</ul>
<p>可以看到，我们传入的key并不是完全利用到了，<strong>而是只取其8位，配合一个15位的参数d_i以及iv中的8位，拼接成一个 8 + 15 + 8共31位的值</strong></p>
<p>这里我们可以看到出现了一个奇怪的参数 ：d_i</p>
<p>它在前面被我们忽视了：<code>_init_d_constants()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def _init_d_constants(self):</span><br><span class="line">    &quot;&quot;&quot;初始化15位常量d_i&quot;&quot;&quot;</span><br><span class="line">    print(&quot;步骤: 初始化15位常量d_i&quot;)</span><br><span class="line">    d_values = [</span><br><span class="line">        0b100010011010111, 0b010011010111100, 0b110001001101011,</span><br><span class="line">        0b001001101011110, 0b101011110001001, 0b011010111100010,</span><br><span class="line">        0b111000100110101, 0b000100110101111, 0b100110101111000,</span><br><span class="line">        0b010111100010011, 0b110101111000100, 0b001101011110001,</span><br><span class="line">        0b101111000100110, 0b011110001001101, 0b111100010011010,</span><br><span class="line">        0b100011110101100</span><br><span class="line">    ]</span><br><span class="line">    return d_values</span><br></pre></td></tr></table></figure>
<p><code>d_i</code>可以看到，它其实是一段段二进制参数，其作用是：<code>通过将密钥（ki）、常数（di）和初始向量（ivi）连接起来，保证了即使密钥或初始向量部分相同，LFSR的初始状态也会因常数的引入而不同。这防止了初始状态全为零或其他弱状态，从而避免了密码分析中的弱点。</code></p>
<p>在ZUC算法中，di 是一组预定义的15位常数（即每个 di 占15位），用于LFSR的初始化。这些常数是ZUC标准的一部分，由算法设计者精心选择，以优化LFSR的统计特性。我们只需要记住：<strong>di是配合我们提供的key和iv使用、用于装填空的LFSR寄存器用的</strong></p>
<p>我们还注意到，每个寄存器只取31位，其原因，作者这里也不完全理解（数学不好），贴上查到的解释：</p>
<ul>
<li>ZUC的LFSR不是工作在传统的基于异或的GF(2)上，而是工作在<strong>模素数 p = 2³¹ - 1</strong> 的有限域 GF(p) 上</li>
<li>这个素数 p 是一个 <strong>梅森素数</strong> 。在GF(p)上设计的LFSR，如果其反馈多项式是一个本原多项式，那么它能够达到的 <strong>最大周期是 p - 1 = 2³¹ - 2</strong> 。这是一个巨大的、已知的、且是可能达到的最大周期。</li>
<li>如果使用32位（2³²），那么模数将是2³²。在GF(2)上，基于异或的LFSR的最大周期是2³² - 1，这虽然也很大，但ZUC的设计者选择了GF(p)这条路径。</li>
</ul>
<p><strong>而key、iv各取8位的原因是将Key、IV和常数d高度混合混，使得分析密钥和输出序列之间的关系变得极其困难</strong></p>
<p>总之，进行16轮这样的key、d、iv的混合后，我们就得到了16个已经“装满货物”的寄存器，到这里，我们提供的key与iv也就尽完它们的职责了，也就是完成<strong>密钥装入</strong></p>
<p><code>initialization_phase()</code>函数接下来还有一步：设置R1、R2为0，还是先跳过（或者直接去看 <code>非线性函数F</code>部分也可）</p>
<p>然后是开始进入到一个32次的循环，这也是ZUC算法的重点，但是我们先一步步介绍循环的函数到底是什么，再来说明为什么循环32次</p>
<h2 id="线性反馈移位寄存器lfsr"><a class="markdownIt-Anchor" href="#线性反馈移位寄存器lfsr"></a> 线性反馈移位寄存器(LFSR)</h2>
<blockquote>
<p>虽然给的代码是 比特重组（BR）——&gt;  非线性函数（F） ——&gt;  线性反馈移位寄存器（LFSR），但是由于这个部分与后面两个部分有紧密关联，所以先提前给出</p>
</blockquote>
<p>还记得我们前面说过：<code>LFSR密码学中它的作用是快速产生一个长周期的伪随机密钥流</code>，其生成的密钥流就是为后面进行混淆的对象，也就是说，<strong>你可以把 <code>LFSR</code>当作我们生成的ZUC密钥流的“种子算法”，负责维护算法的大部分内部状态。</strong></p>
<p>伪随机的原因是其具有周期性，最大为 <code> 2^n - 1</code>（原理可自己查查），但是我们设置16个31为LFSR意味着状态空间高达496位，在数学上足以抵抗暴力破解</p>
<p>那么它是如何长周期产生一个长周期的伪伪随机密钥流的呢？</p>
<p>我们结合一下算法标准结构图来看看其实际计算流程：</p>
<p><img src="https://golden-forest.top/190b49413bda101392e6c0fd029fa4af.png" alt="" /></p>
<p>（简单处理了一下）</p>
<p><strong>其逻辑就是：取s15、s13、s10、s4、s0这5个值，进行一堆运算之后，得到一个新值s16，并将s0踢出去，将得到的s16放到最后。</strong></p>
<p>这个流程就像是我们砍竹子（比喻也许不够恰当），一根竹子一共16节（最多且必须），我们把最头部的一节砍了（丢掉s0），然后底部长出一根新节（生成s16）。这样子就能保证，整根竹子都处于最嫩的状态（一直在更新），且会一直保持生长（一直保持16节）</p>
<p>那么我们是如何得到这个新的竹节，也就是 <code>s16</code>的呢？</p>
<p>来看代码：<code>lfsr_initialization_mode(u)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def lfsr_initialization_mode(self, u):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    5.2.2 LFSR初始模式</span><br><span class="line">    LFSR接收1个31比特字u的输入，更新寄存器</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # (1) 计算v</span><br><span class="line">    v = self.mod_231_1_mult(2**15, self.LFSR[15])</span><br><span class="line">    v = self.mod_231_1_add(v, self.mod_231_1_mult(2**17, self.LFSR[13]))</span><br><span class="line">    v = self.mod_231_1_add(v, self.mod_231_1_mult(2**21, self.LFSR[10]))</span><br><span class="line">    v = self.mod_231_1_add(v, self.mod_231_1_mult(2**20, self.LFSR[4]))</span><br><span class="line">    v = self.mod_231_1_add(v, self.mod_231_1_mult((1 + 2**8), self.LFSR[0]))</span><br><span class="line">  </span><br><span class="line">    # (2) 计算s16</span><br><span class="line">    s16 = self.mod_231_1_add(v, u)</span><br><span class="line">  </span><br><span class="line">    # (3) 如果s16=0，则置s16=2^31-1</span><br><span class="line">    if s16 == 0:</span><br><span class="line">        s16 = 2**31 - 1</span><br><span class="line">  </span><br><span class="line">    # (4) 移位操作</span><br><span class="line">    for i in range(15):</span><br><span class="line">        self.LFSR[i] = self.LFSR[i + 1]</span><br><span class="line">    self.LFSR[15] = s16</span><br><span class="line">  </span><br><span class="line">    return s16</span><br></pre></td></tr></table></figure>
<p>但是，如果你先提前全部浏览整个文章，会发现还有个函数与LFSR有关：<code>lfsr_work_mode(self)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def lfsr_work_mode(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    5.2.3 LFSR工作模式</span><br><span class="line">    LFSR无输入，直接更新寄存器</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # (1) 计算s16</span><br><span class="line">    s16 = self.mod_231_1_mult(2**15, self.LFSR[15])</span><br><span class="line">    s16 = self.mod_231_1_add(s16, self.mod_231_1_mult(2**17, self.LFSR[13]))</span><br><span class="line">    s16 = self.mod_231_1_add(s16, self.mod_231_1_mult(2**21, self.LFSR[10]))</span><br><span class="line">    s16 = self.mod_231_1_add(s16, self.mod_231_1_mult(2**20, self.LFSR[4]))</span><br><span class="line">    s16 = self.mod_231_1_add(s16, self.mod_231_1_mult((1 + 2**8), self.LFSR[0]))</span><br><span class="line">  </span><br><span class="line">    # (2) 如果s16=0，则置s16=2^31-1</span><br><span class="line">    if s16 == 0:</span><br><span class="line">        s16 = 2**31 - 1</span><br><span class="line">  </span><br><span class="line">    # (3) 移位操作</span><br><span class="line">    for i in range(15):</span><br><span class="line">        self.LFSR[i] = self.LFSR[i + 1]</span><br><span class="line">    self.LFSR[15] = s16</span><br><span class="line">  </span><br><span class="line">    return s16</span><br></pre></td></tr></table></figure>
<p>s <code>s16</code>有两种生成办法？！这实际上这告诉我们：<strong>LFSR有两个状态</strong>。为什么？</p>
<p><strong>这实际上就是ZUC算法的核心设计：这两种模式的存在是为了解决一个根本矛盾：<strong>如何从一个确定的密钥和IV出发，最终生成一个随机、不可预测且“高效生成”的密钥流？答案就是加入“混淆与扩散”。</strong></strong></p>
<ul>
<li><strong>密钥装填</strong>：实现了从一个密钥（key）和向量（IV）出发</li>
<li><strong>初始模式</strong> ：目的是 <strong>“混淆和扩散”</strong> ，将算法内部状态“打乱”，使其达到一个充分随机的起始点，<strong>看不出内部状态与我们的IV、密钥的关系</strong>（注意只是起始点，还是不能直接作为密码使用！后面会解释）</li>
</ul>
<ul>
<li><strong>工作模式</strong> ：目的是 <strong>“高效生成”</strong> ,可以快速得到安全可靠的密钥流。</li>
</ul>
<p>我们来一步步介绍这两个函数（状态）</p>
<h3 id="初始模式"><a class="markdownIt-Anchor" href="#初始模式"></a> 初始模式</h3>
<p>首先来看 <code>lfsr_initialization_mode(u)</code>，也就是 <code>LFSR初始模式</code>：</p>
<p>我们在前面已经进行过 <code>密钥装入</code>，也就是把<strong>IV和key还有常数d</strong>装进16个31位空的寄存器里面了，接下来为了<strong>实现我们“看不出内部状态与我们的IV、密钥的关系”的目标</strong>，就需要打乱现在16个31位寄存器的关系</p>
<p>可以看到，<strong>初始模式生成 <code>s16</code>的过程需要提供一个31位的输入 <code>u</code></strong>，其来源可以在 <code>initialization_phase(self)</code>函数中看到，来自 <code>非线性函数F</code>的运行结果，我们后面再讲这一步，这里我们就把 <code>u</code>当作一个安全的、可靠的“搅屎棍”</p>
<p>先来看我们计算s16的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># (1) 计算v</span><br><span class="line">v = self.mod_231_1_mult(2**15, self.LFSR[15])</span><br><span class="line">v = self.mod_231_1_add(v, self.mod_231_1_mult(2**17, self.LFSR[13]))</span><br><span class="line">v = self.mod_231_1_add(v, self.mod_231_1_mult(2**21, self.LFSR[10]))</span><br><span class="line">v = self.mod_231_1_add(v, self.mod_231_1_mult(2**20, self.LFSR[4]))</span><br><span class="line">v = self.mod_231_1_add(v, self.mod_231_1_mult((1 + 2**8), self.LFSR[0]))</span><br><span class="line">  </span><br><span class="line"># (2) 计算s16</span><br><span class="line">s16 = self.mod_231_1_add(v, u)</span><br></pre></td></tr></table></figure>
<p>可以看到LFSR的初始模式，计算中间值 <code>v</code>与 <code>S16</code>时，分别调用了两个函数： <code>mod_231_1_mult(self, a, b)</code>、<code>mod_231_1_add(self, a, b)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def mod_231_1_add(self, a, b):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    模2^31-1加法实现</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    result = a + b</span><br><span class="line">    # 模2^31-1运算</span><br><span class="line">    result = (result &amp; 0x7FFFFFFF) + (result &gt;&gt; 31)</span><br><span class="line">    return result</span><br><span class="line">  </span><br><span class="line">def mod_231_1_mult(self, a, b):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    模2^31-1乘法实现</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 简单的模乘法实现</span><br><span class="line">    # 在实际应用中可以使用更高效的实现</span><br><span class="line">    return (a * b) % (2**31 - 1)</span><br></pre></td></tr></table></figure>
<p>这两个函数其实就是我们结构图中对 <code>s15</code>它们进行的运算，本质是是一种 <code>模运算</code>（记住如何实现就行）</p>
<p>来介绍一下 <code>v</code>：<code>LFSR</code><strong>线性特性的集中体现：</strong></p>
<ul>
<li><strong>线性混合</strong> ：<code>v</code> 是由 <code>LFSR</code>中 <strong>5个特定寄存器</strong> <code>s15, s13, s10, s4, s0</code>通过线性组合计算得出的。</li>
<li><strong>扩散作用</strong> ：这些寄存器在 <code>LFSR</code>中分布较广（索引0,4,10,13,15），确保了 <code>LFSR</code>状态的广泛参与。</li>
<li><strong>数学基础</strong> ：计算基于 <code>Galois域 GF(2^31-1)</code> 上的运算（与31位寄存器对应），保证了LFSR能达到最大周期。</li>
</ul>
<p>没事，我也看不懂这里面的数学逻辑，但是，<strong>简单说：<code>v</code> 代表了LFSR&quot;本来应该&quot;按照线性规则生成的下一个状态。</strong></p>
<p>初始模式最关键的是 <code>s16</code>的得到方式，将前面得到的 <code>线性的v</code>与我们给的  <code>非线性的u</code>进行了 <code>模加法</code>，然后丢掉 <code>LFSR</code>最前面的一个值 <code>s0</code>，将 <code>s16</code>放到最后，这意味着，相当于在 <code>LFSR</code>的<strong>线性序列中植入了非线性基因</strong></p>
<p>举个例子：</p>
<p>对于一个一般的可破解 <code>LFSR</code>序列在程序的眼里长这样:<code> a-b-c-d-e-f-1-2-3-4-5-6</code></p>
<p>在加入了 <code>s16</code>整个非线性基因后，可以长这样 <code>b-c-d-e-f-1-2-3-4-5-6-🔣</code></p>
<p>而这个🔣即使与前一个状态：<code>a-b-c-d-e-f-1-2-3-4-5-6</code>有密切关系，但是就算你是计算机本体都看不出这玩意到底和我们的密钥、IV有半毛钱关系，<strong>实现了我们“扩散与混淆”的目的</strong></p>
<p>当然简单一轮是完全不够的， <strong><code>initialization_phase(self)</code>函数中进行了32轮这样的****非线性基因植入，足够达到了一个高度随机化的&quot;混沌&quot;状态.</strong></p>
<h3 id="工作模式"><a class="markdownIt-Anchor" href="#工作模式"></a> 工作模式</h3>
<p>达到我们要的混沌状态之后，就不需要我们继续提供 <code>非线性的u</code>了，之后只需要让它愉快地产生随机密钥流即可，在代码中，我们可以看到 这个模式下的 <code>s16</code>算法与初始模式的 <code>v</code>一致，即：<strong>在我们初始模式中，生成 <code>v</code>的算法，就是工作模式生成 <code>s16</code>的算法，就不过多介绍了</strong></p>
<h3 id="为什么不能直接作为密钥使用"><a class="markdownIt-Anchor" href="#为什么不能直接作为密钥使用"></a> 为什么不能直接作为密钥使用</h3>
<p>但是！正如我们代码中看到的，<strong>虽然 <code>key、IV</code>和 <code>LFSR</code>生成的密钥流序列的 <code>内部关系</code>是非线性的，但是 <code>LFSR</code>生成的密钥流的 <code>外部关系</code>是线性的</strong>，这意味着攻击者只需要截获一小段输出序列（2n个比特），就可以通过解一个线性方程组（例如使用 <code>Berlekamp-Massey</code>算法）轻松地推算出 <code>LFSR</code>的<strong>反馈多项式</strong>和整个后续输出序列，从而完全破解加密。</p>
<p>所以，不能直接将得到的 <code>LFSR密钥流</code>作为真正的密钥流使用，那该怎么办呢？接下来我们要介绍的 <code>比特重组</code>和 <code>非线性函数F</code>就是为了解决这个问题而设计的</p>
<h2 id="比特重组br"><a class="markdownIt-Anchor" href="#比特重组br"></a> 比特重组(BR)</h2>
<p>这一步代码非常简单，来看 <code>比特重组</code>的函数：<code>bit_reconstruction()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def bit_reconstruction(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    比特重组(BR)</span><br><span class="line">    从LFSR寄存器中重组4个32位字X0, X1, X2, X3</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 提取LFSR寄存器的高16位和低16位</span><br><span class="line">    s15H = (self.LFSR[15] &gt;&gt; 15) &amp; 0xFFFF  # s15的高16位</span><br><span class="line">    s14L = self.LFSR[14] &amp; 0x7FFF          # s14的低15位</span><br><span class="line">    s11H = (self.LFSR[11] &gt;&gt; 15) &amp; 0xFFFF  # s11的高16位</span><br><span class="line">    s9L = self.LFSR[9] &amp; 0x7FFF            # s9的低15位</span><br><span class="line">    s7H = (self.LFSR[7] &gt;&gt; 15) &amp; 0xFFFF    # s7的高16位</span><br><span class="line">    s5L = self.LFSR[5] &amp; 0x7FFF            # s5的低15位</span><br><span class="line">    s2H = (self.LFSR[2] &gt;&gt; 15) &amp; 0xFFFF    # s2的高16位</span><br><span class="line">    s0L = self.LFSR[0] &amp; 0x7FFF            # s0的低15位</span><br><span class="line">  </span><br><span class="line">    # 重组32位字</span><br><span class="line">    X0 = (s15H &lt;&lt; 16) | s14L</span><br><span class="line">    X1 = (s11H &lt;&lt; 16) | s9L</span><br><span class="line">    X2 = (s7H &lt;&lt; 16) | s5L</span><br><span class="line">    X3 = (s2H &lt;&lt; 16) | s0L</span><br><span class="line">  </span><br><span class="line">    return X0, X1, X2, X3</span><br></pre></td></tr></table></figure>
<p><strong><code>比特重组（BR）</code></strong> 是ZUC算法中一个非常精巧且关键的设计，它充当了 <code>LFSR</code>（线性部分）和 <code>非线性函数F</code>（非线性部分）之间的&quot;桥梁&quot;。简单来说，<code>比特重组</code>做了一件看似简单但至关重要的事情：<strong>它从 <code>LFSR</code>的16个寄存器中，有选择地、按特定规则抽取一些位，然后重新打包成4个32位的字（X0, X1, X2, X3），供后续步骤（<code>非线性函数F</code>）使用</strong></p>
<p>具体来说，其<strong>抽取的寄存器、每个寄存器抽取的位</strong>是固定的：</p>
<p><img src="https://golden-forest.top/c0ae5d7201acf6c73161f2a0c68e3c4e.png" alt="" /></p>
<p>由于 <code>LFSR</code>的更新是“去头填尾”，相邻寄存器存在<strong>强关联</strong>，而 <code>比特重组</code>以不连续、广泛的方式去抽值，可以去除这种<strong>强关联</strong>，达到<strong>扩散</strong>的目的</p>
<p>而 <code>比特重组</code>返回的结果，4个32位字 <code>X0, X1, X2, X3</code>中，只有  <code>X0, X1, X2 </code>被送入 <code>非线性函数F </code>当中，而 <code>X3</code>将会与 <code>非线性函数F</code>得到的 <code>w</code>进行异或，得到我们用来进行 <code>LFSR的初始模式</code>的 <code>u</code>，<strong>这样设计即实现了非线性，又保证了效率</strong></p>
<p>知道了 <code>比特重组</code>的作用后，就可以看整个ZUC算法最复杂的一部分——<code>非线性函数F</code>了</p>
<h2 id="非线性函数f"><a class="markdownIt-Anchor" href="#非线性函数f"></a> 非线性函数F</h2>
<p><code>非线性函数F </code>是ZUC算法的安全核心，它负责将LFSR产生的 <code>线性密钥流 </code><strong>转换为 <code>非线性密钥流</code></strong>。让我们先看看它的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def nonlinear_function_F(self, X0, X1, X2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    输入: X0, X1, X2 (32位字)</span><br><span class="line">    输出: W (32位字)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # (1) W = (X0 ⊕ R1) + R2 mod 2^32</span><br><span class="line">    W = ((X0 ^ self.R1) + self.R2) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">    # (2) W1 = R1 + X1 mod 2^32</span><br><span class="line">    W1 = (self.R1 + X1) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">    # (3) W2 = R2 ⊕ X2</span><br><span class="line">    W2 = self.R2 ^ X2</span><br><span class="line">  </span><br><span class="line">    # (4) R1 = S[L1(W1H || W2L)]</span><br><span class="line">    W1H = (W1 &gt;&gt; 16) &amp; 0xFFFF  # W1的高16位</span><br><span class="line">    W2L = W2 &amp; 0xFFFF          # W2的低16位</span><br><span class="line">    R1_input = (W1H &lt;&lt; 16) | W2L</span><br><span class="line">    self.R1 = self.sbox.sbox_32(self.linear_transform_L1(R1_input))</span><br><span class="line">  </span><br><span class="line">    # (5) R2 = S[L2(W2H || W1L)]</span><br><span class="line">    W2H = (W2 &gt;&gt; 16) &amp; 0xFFFF  # W2的高16位</span><br><span class="line">    W1L = W1 &amp; 0xFFFF          # W1的低16位</span><br><span class="line">    R2_input = (W2H &lt;&lt; 16) | W1L</span><br><span class="line">    self.R2 = self.sbox.sbox_32(self.linear_transform_L2(R2_input))</span><br><span class="line">  </span><br><span class="line">    return W</span><br></pre></td></tr></table></figure>
<p>可以看到，其所用参数就是我们 <code>比特重组</code>一步得到的 <code>X0、X1、X2</code></p>
<p>而返回的输出 <code>W</code>，实际上在该函数开头通过 <code>W = (X0 ⊕ R1) + R2 mod 2^32</code>这段代码就已经计算完毕了，那么后面一大段函数用来干什么呢？</p>
<p>而其中所需用到 <code>R1、R2</code>两个前面提到过的参数与 <code>sbox_32(self, X)、linear_transform_L1(self, X)、linear_transform_L2(self, X)</code>这三个函数又是什么呢？</p>
<h3 id="记忆单元r1-r2"><a class="markdownIt-Anchor" href="#记忆单元r1-r2"></a> 记忆单元R1、R2</h3>
<p>我们先来介绍 <code>R1、R2</code>这两个参数到底是什么：<code>在ZUC算法的文档中，R1和R2被称为  32位记忆单元 。它们本质上就是两个32位的寄存器，在算法运行过程中会不断地被更新。同时保持非线性关系</code></p>
<p>正如其名字一样，它们两的作用是“记忆”，说起来有点抽象，我们先来思考这么一个问题：</p>
<ul>
<li>如果每一轮产生的密钥流都只依赖于当前 <code>LFSR</code>的状态，<strong>那么 <code>密钥流</code>之间的关系就是相互独立的</strong>。攻击者可以孤立地分析每一段 <code>密钥流</code>（这里一段 <code>密钥流</code>实际上就是一次 <code>LFSR</code>运算生成的新31位数据）。</li>
<li>这意味着，<strong>攻击者截取到的密钥流片段对攻击来说是有意义的（具体多少没细研究）</strong></li>
<li><strong>如何在不断生成的一段段密钥流中，建立起联系，使得攻击者即使拿到其中一个片段都没有用呢？</strong></li>
</ul>
<p>设计者的解决方案是：引入 <code>R1、R2</code>这两个“记忆单元”，“记住”当前的 <code>密钥流</code>状态，<strong>让它们两加入到生成新的密钥流过程中</strong>。意思是：在 <code>LFSR</code>的第 <code>n</code>轮的计算中，此时 <code>R1、R2</code>它们的状态是第 <code>n-1</code>轮计算的结果，并且，由于迭代，当前的 <code>R1、R2</code>包括了过去所有轮次的“历史信息”，更准确地说，此时 <code>LFSR</code>的第 <code>n</code>轮的计算，与前 <code>n-1</code>轮都有关系</p>
<p>这使得 <code>密钥流</code><strong>不再是一个独立的序列，而是一个连续的、前后高度关联的数据流</strong>。第100个 <code>密钥字</code>依赖于第99个，第99个依赖于第98个……一直回溯到初始化阶段。这极大地增加了密码分析的难度。</p>
<p>回到我们开头的看到的ZUC算法初始化函数，由于我们一开始并没有进行过 <code>LFSR</code>运算，所以开始一要将 <code>R1、R2</code>置0</p>
<p>然后回到 <code>非线性函数F</code>，我们已经知道了 <code>R1、R2</code>的作用了，所以我们也能理解 <code>w</code>的结构图中的生成是如何而来的了:</p>
<p><img src="https://golden-forest.top/449c2dc27494b41e49e2e9c24daf744a.png" alt="" /></p>
<p>即↓</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># (1) W = (X0 ⊕ R1) + R2 mod 2^32</span><br><span class="line">W = ((X0 ^ self.R1) + self.R2) &amp; 0xFFFFFFFF</span><br></pre></td></tr></table></figure>
<p>这里就体现了<strong>后面生成的密钥流是与前面生成的密钥流有强联系的。</strong></p>
<p>知道了 <code>R1、R2</code>的作用后，我们来来看看更新的 <code>R1、R2</code>的算法到底是什么：</p>
<p>为了方便理解接下来个个函数的关系与顺序，先奉上结构图（稍微处理了一下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">self.R1 = self.sbox.sbox_32(self.linear_transform_L1(R1_input))</span><br><span class="line">self.R2 = self.sbox.sbox_32(self.linear_transform_L2(R2_input))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="sbox"><a class="markdownIt-Anchor" href="#sbox"></a> Sbox</h3>
<blockquote>
<p>按照图中标号顺序，我按照<strong>倒序</strong>的方法来介绍 <code>R1、R2</code>的更新过程。</p>
</blockquote>
<p><img src="https://golden-forest.top/dec325ab30f47f3c261757530fb9bd3d.png" alt="" /></p>
<p>首先我们来看整个代码最核心的部分——<code>非线性的Sbox</code>。我们在前面提到一个类 <code>ZUCSBox()</code>，其构造函数长这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    print(&quot;初始化ZUC S盒...&quot;)</span><br><span class="line">    self.S0 = self._create_s0()</span><br><span class="line">    self.S1 = self._create_s1()</span><br><span class="line"></span><br><span class="line">def _create_s0(self):</span><br><span class="line">    &quot;&quot;&quot;创建S0盒的一维查找表&quot;&quot;&quot;</span><br><span class="line">    S0_table = [</span><br><span class="line">        [0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54, 0x98, 0x09, 0xB9, 0x6D, 0xCB],</span><br><span class="line">        [0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D, 0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90],</span><br><span class="line">        [0x4D, 0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48, 0x8B, 0x29, 0x6E, 0xAC],</span><br><span class="line">        [0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69, 0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38],</span><br><span class="line">        [0x76, 0x7D, 0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21, 0x06, 0x55, 0x9B],</span><br><span class="line">        [0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4, 0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C],</span><br><span class="line">        [0x4A, 0x16, 0xD5, 0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01, 0xD3, 0xAD],</span><br><span class="line">        [0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F, 0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8],</span><br><span class="line">        [0xB1, 0xB4, 0x37, 0xF7, 0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96, 0x56],</span><br><span class="line">        [0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE],</span><br><span class="line">        [0xBC, 0x26, 0x95, 0x88, 0x8A, 0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D],</span><br><span class="line">        [0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12, 0xF5, 0x74, 0x9C, 0xAA, 0x23],</span><br><span class="line">        [0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02, 0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1],</span><br><span class="line">        [0xF6, 0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6, 0x40, 0xC4, 0xE2, 0x0F],</span><br><span class="line">        [0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F, 0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65],</span><br><span class="line">        [0x8D, 0x27, 0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE, 0x78, 0x34, 0x60]</span><br><span class="line">    ]</span><br><span class="line">  </span><br><span class="line">    s0_1d = [0] * 256</span><br><span class="line">    for i in range(16):</span><br><span class="line">        for j in range(16):</span><br><span class="line">            s0_1d[i * 16 + j] = S0_table[i][j]</span><br><span class="line">    return s0_1d</span><br></pre></td></tr></table></figure>
<p><code>S0</code>和 <code>S1</code>是两个精心设计的“<strong>输入8位，输出8位</strong>”的<strong>非线性查找表，简称 <code>Sbox</code></strong>，但是，我们在上面代码可以看见，这个 <code>Sbox</code>一共有<strong>256个8位（两个16进制）值</strong>，如何实现的**“输入8位，输出8位”**呢？</p>
<p>其实，在  <code>sbox.sbox_32(self, X)</code>函数中就已经展示了查找的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def sbox_32(self, X):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param X: 32位输入</span><br><span class="line">    :return: 32位输出</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 将32位输入分解为4个8位字节</span><br><span class="line">    x0 = (X &gt;&gt; 24) &amp; 0xFF</span><br><span class="line">    x1 = (X &gt;&gt; 16) &amp; 0xFF</span><br><span class="line">    x2 = (X &gt;&gt; 8) &amp; 0xFF</span><br><span class="line">    x3 = X &amp; 0xFF</span><br><span class="line">  </span><br><span class="line">    # 分别应用S盒</span><br><span class="line">    y0 = self.S0[x0]</span><br><span class="line">    y1 = self.S1[x1]</span><br><span class="line">    y2 = self.S0[x2]  # S2 = S0</span><br><span class="line">    y3 = self.S1[x3]  # S3 = S1</span><br><span class="line">  </span><br><span class="line">    # 重新组合为32位输出</span><br><span class="line">    Y = (y0 &lt;&lt; 24) | (y1 &lt;&lt; 16) | (y2 &lt;&lt; 8) | y3</span><br><span class="line">    return Y</span><br></pre></td></tr></table></figure>
<p>这个函数接受了一个 <code>32位x</code>，然后，将其分为<strong>4个8位的值</strong>，即一个<strong>2位16进制数（形如0xFF）</strong>,<strong>将其作为索引直接取 <code>Sbox</code>中的对应的值（也是8位）</strong>，最后将得到的4个对应得8位值拼接为一个32位值</p>
<p>这里不难看出，<strong>8位的值作为索引共有2^8=256种情况，所以是256个8位值</strong></p>
<p>而有两个 <code>Sbox</code>的原因，主要有三：</p>
<ul>
<li>如果只用一个 <code>Sbox</code>，算法中会出现很多的对称性和重复模式。<strong>交替使用 <code>S0</code>和 <code>S1</code>打破了这种对称性，增加了算法的复杂性。</strong></li>
<li>两个不同的 <code>Sbox</code>意味着攻击者<strong>需要同时分析两个独立的非线性系统</strong>，而不是一个。这样可以<strong>平方级地增加</strong>了代数攻击的难度。</li>
<li>不同的 <code>Sbox</code>减少了出现固定点（如 <code>S(x) = x</code>）和其他简单代数关系的概率。</li>
</ul>
<p>顺带一提，为什么是8位？解释有很多，不过最好的记忆方法是：</p>
<ul>
<li><strong>8位（其实就算1字节）是现代计算机体系结构的基本处理单元。</strong></li>
</ul>
<p><strong>由于本身 <code>Sbox</code>是 <code>非线性</code>的，于是有了以下 <code>非线性传递链</code>（以下参数都是前面出现过的）：<code>Sbox -&gt; R1/R2 -&gt; w -&gt; u -&gt; LFSR生成的密钥流 -&gt; ZUC生成的密钥流</code></strong></p>
<p>总而言之，<strong>新 <code>R1、R2</code>的值</strong>就是通过传入 <code>32位x</code>作为索引，在 <code>Sbox</code>中查找对应的值得到的，那么，这个 <code>32位x</code>又是怎么来的呢？</p>
<h3 id="线性变换"><a class="markdownIt-Anchor" href="#线性变换"></a> 线性变换</h3>
<p>还是刚刚那个函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">self.R1 = self.sbox.sbox_32(self.linear_transform_L1(R1_input))</span><br><span class="line">self.R2 = self.sbox.sbox_32(self.linear_transform_L2(R2_input))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到我们传入的 <code>32位x</code>的参数实际上是另两个函数的计算结果:<code>linear_transform_L1(self, X)、linear_transform_L2(self, X)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def linear_transform_L1(self, X):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    线性变换L1</span><br><span class="line">    L1(X) = X ⊕ (X &lt;&lt;&lt; 2) ⊕ (X &lt;&lt;&lt; 10) ⊕ (X &lt;&lt;&lt; 18) ⊕ (X &lt;&lt;&lt; 24)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def rotate_left_32(x, n):</span><br><span class="line">        &quot;&quot;&quot;32位循环左移&quot;&quot;&quot;</span><br><span class="line">        return ((x &lt;&lt; n) | (x &gt;&gt; (32 - n))) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">    result = X</span><br><span class="line">    result ^= rotate_left_32(X, 2)</span><br><span class="line">    result ^= rotate_left_32(X, 10)</span><br><span class="line">    result ^= rotate_left_32(X, 18)</span><br><span class="line">    result ^= rotate_left_32(X, 24)</span><br><span class="line">  </span><br><span class="line">    return result &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">def linear_transform_L2(self, X):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    线性变换L2</span><br><span class="line">    L2(X) = X ⊕ (X &lt;&lt;&lt; 8) ⊕ (X &lt;&lt;&lt; 14) ⊕ (X &lt;&lt;&lt; 22) ⊕ (X &lt;&lt;&lt; 30)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def rotate_left_32(x, n):</span><br><span class="line">        &quot;&quot;&quot;32位循环左移&quot;&quot;&quot;</span><br><span class="line">        return ((x &lt;&lt; n) | (x &gt;&gt; (32 - n))) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line">    result = X</span><br><span class="line">    result ^= rotate_left_32(X, 8)</span><br><span class="line">    result ^= rotate_left_32(X, 14)</span><br><span class="line">    result ^= rotate_left_32(X, 22)</span><br><span class="line">    result ^= rotate_left_32(X, 30)</span><br><span class="line">  </span><br><span class="line">    return result &amp; 0xFFFFFFFF</span><br></pre></td></tr></table></figure>
<p>这两个函数称之为 <code>线性变换</code>，其最重要的功能即是实现“扩散”，简单来说，经过这么一个 <code>线性变换</code>操作，在 <code>密钥流</code>中，只要我们改动小小一个bit，就会影响输出中多个、看似不相关的bit，这极大确保了 <code>整体密钥流</code>的安全性</p>
<p>那么为什么会有两个 <code>线性变换</code>算法呢？粗俗点讲，这两个 <code>线性变换</code>的扩散程度不一样，使得攻击会更复杂，且攻击者还需猜测用的那种变换，增强安全性</p>
<p>虽然两个函数看起来代码很长，但是数学公式很好理解：<code>L1(X) = X ⊕ (X &lt;&lt;&lt; 2) ⊕ (X &lt;&lt;&lt; 10) ⊕ (X &lt;&lt;&lt; 18) ⊕ (X &lt;&lt;&lt; 24)</code>、<code>L2(X) = X ⊕ (X &lt;&lt;&lt; 8) ⊕ (X &lt;&lt;&lt; 14) ⊕ (X &lt;&lt;&lt; 22) ⊕ (X &lt;&lt;&lt; 30)</code></p>
<p>对我们来说用代码实现还是很好理解的</p>
<h3 id="交叉重组"><a class="markdownIt-Anchor" href="#交叉重组"></a> 交叉重组</h3>
<p>最后，我们来看看是谁被进行了 <code>线性变换</code>，也就是 <code>R1_input</code>，来看看它是如何得到的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># W1 = R1 + X1 mod 2^32</span><br><span class="line">W1 = (self.R1 + X1) &amp; 0xFFFFFFFF</span><br><span class="line">  </span><br><span class="line"># W2 = R2 ⊕ X2</span><br><span class="line">W2 = self.R2 ^ X2</span><br><span class="line">  </span><br><span class="line">W1H = (W1 &gt;&gt; 16) &amp; 0xFFFF  # W1的高16位</span><br><span class="line">W2L = W2 &amp; 0xFFFF          # W2的低16位</span><br><span class="line"></span><br><span class="line">R1_input = (W1H &lt;&lt; 16) | W2L</span><br><span class="line"></span><br><span class="line">self.R1 = self.sbox.sbox_32(self.linear_transform_L1(R1_input))</span><br></pre></td></tr></table></figure>
<p>可以看到，在我们进行 <code>线性变换</code>之前，还将 <code>R1、R2</code>处理了一下，这一步叫做 <code>交叉重组</code>，其思路也简单，<strong>就是将 <code>R1、R2</code>，配合我们 <code>比特重组</code>得到的 <code>X1、X2</code>进行重新排列组合</strong>，这样做的目的也是我们一直在做的：加入“扩散”。将 <code>R1、R2</code>混合在一起，这样这两个参数的<strong>内在关系</strong>也不再是孤立的了，这样攻击者光有其中一个参数也<strong>不足以造成一次有效攻击</strong></p>
<p>其数学逻辑看代码就很好理解了，就不做过多介绍到目前为止，我们就介绍完了 <code>非线性函数F</code>的所有关键操作了，但是由于我们是倒着讲的，所有这里我们重新梳理以下真正的操作：<code>生成新w -&gt; 将R1、R2交叉重组 -&gt; 线性变换 -&gt; Sbox查表</code></p>
<p>经历了这么复杂的一个过程，我们就能<strong>将我们从 <code>LFSR</code>中生成的密钥流进行“扩散与混淆”</strong>，保证了密码的安全性，<strong>这一个个经过“扩散与混淆的”<code>密钥流</code>，才能够真正作为我们去可靠使用的密钥去加密数据</strong></p>
<h2 id="小梳理"><a class="markdownIt-Anchor" href="#小梳理"></a> 小梳理</h2>
<p>到这里，我们终于看完了初始化函数：<code>zuc.initialization_phase()</code>，回顾一下我们干了什么：</p>
<ul>
<li>首先，我们看到开始会初始化一堆我们后面将会用到的参数，包括 <code>R1、R2、Sbox</code>填充等</li>
<li>其次，我们理解了我们传入的参数 <code>key、IV</code>的作用 —— 用于<strong>填充空的16个31位寄存器（<code>LFSR</code>）</strong></li>
<li>之后，我们进行了32轮如下操作，其中<strong>真正的目的是完成 <code>LFSR</code>的初始模式</strong>，<strong>就是要将 <code>key、IV</code>完全混合在我们的 <code>LFSR</code>中，即进行 <code>LFSR内部关系</code>的“扩散与混淆”</strong></li>
<li>第一步，我们看到，进行了 <code>比特重组</code>，也就是取 <code>LFSR</code>中的几个值去做混合，为接下来的 <code>非线性函数F</code>做预处理工作</li>
<li>第二步，我们把处理过的参数 <code>V0....V3</code>交给了 <code>非线性函数F</code>，其进行了 <code>生成新w -&gt; 将R1、R2交叉重组 -&gt; 线性变换 -&gt; Sbox查表 </code>等操作后，得到了下一次要用的 <code>R1、R2</code>，以及处理好的 <code>w</code>，对 <code>32位的w</code>去除1位，就得到了我们要加入 <code>LFSR</code>的 <code>u</code></li>
<li>第三步，我们将生成的 <code>u</code>给加入到新的 <code>LFSR</code>中。如此进行32轮，就再也看不出当前 <code>LFSR</code>的 <code>密钥流</code>与我们初始 <code>key、IV</code>的关系了</li>
</ul>
<h2 id="加密解密"><a class="markdownIt-Anchor" href="#加密解密"></a> 加密解密</h2>
<p>接着我们来看接下来的关键函数：<code>keystream=zuc.generate_keystream(key_words_needed)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">def generate_keystream(self, L):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    5.6.3 工作步骤</span><br><span class="line">    生成L个32位密钥字</span><br><span class="line">    :param L: 需要生成的密钥字数量</span><br><span class="line">    :return: 密钥字列表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(&quot;=== 工作步骤开始 ===&quot;)</span><br><span class="line">    print(f&quot;目标: 生成&#123;L&#125;个32位密钥字&quot;)</span><br><span class="line">  </span><br><span class="line">    keystream = []</span><br><span class="line">  </span><br><span class="line">    # (a) 执行一次工作阶段初始化</span><br><span class="line">    print(&quot;步骤(a): 工作阶段初始化&quot;)</span><br><span class="line">    X0, X1, X2, X3 = self.bit_reconstruction()</span><br><span class="line">    print(f&quot;  比特重组: X0=&#123;X0:08x&#125;, X1=&#123;X1:08x&#125;, X2=&#123;X2:08x&#125;, X3=&#123;X3:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">    self.nonlinear_function_F(X0, X1, X2)</span><br><span class="line">    print(f&quot;  非线性函数F: R1=&#123;self.R1:08x&#125;, R2=&#123;self.R2:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">    self.lfsr_work_mode()</span><br><span class="line">    print(&quot;  LFSR工作模式更新完成&quot;)  </span><br><span class="line">    # (b) 重复计算L次</span><br><span class="line">    print(f&quot;步骤(b): 生成&#123;L&#125;个密钥字&quot;)</span><br><span class="line">    for i in range(L):</span><br><span class="line">        print(f&quot;  第&#123;i+1&#125;个密钥字生成:&quot;)</span><br><span class="line">  </span><br><span class="line">        # 1) 比特重组</span><br><span class="line">        X0, X1, X2, X3 = self.bit_reconstruction()</span><br><span class="line">        print(f&quot;    比特重组: X0=&#123;X0:08x&#125;, X1=&#123;X1:08x&#125;, X2=&#123;X2:08x&#125;, X3=&#123;X3:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">        # 2) Z = F(X0,X1,X2) ⊕ X3</span><br><span class="line">        F_output = self.nonlinear_function_F(X0, X1, X2)</span><br><span class="line">        Z = F_output ^ X3</span><br><span class="line">        print(f&quot;    密钥字计算: F=&#123;F_output:08x&#125;, Z=F⊕X3=&#123;Z:08x&#125;&quot;)</span><br><span class="line">  </span><br><span class="line">        # 3) 输出密钥字Z</span><br><span class="line">        keystream.append(Z)</span><br><span class="line">  </span><br><span class="line">        # 4) LFSR工作模式</span><br><span class="line">        self.lfsr_work_mode()</span><br><span class="line">        print(f&quot;    LFSR工作模式更新完成&quot;)</span><br><span class="line">  </span><br><span class="line">    print(&quot;=== 工作步骤完成 ===\n&quot;)</span><br><span class="line">    return keystream</span><br></pre></td></tr></table></figure>
<p>这里有一个疑问点：为什么还要进行一次<strong>工作阶段初始化？</strong></p>
<p>其实很简单：我们前面进行 <code>比特重组</code>+<code>非线性函数F</code>生成的值，最后都加入到 <code>LFSR</code>中了，也就是说，这些 <code>密钥流字</code>都是“非线性改造过的”，但是，在工作模式下的 <code>LFSR</code>，我们要的是“纯线性”的 <code>密钥流字</code>，<strong>所以，我们需要进行一次工作初始化，即把第一次生成的 <code>密钥流字</code>给“丢弃了”</strong></p>
<p>当然另一种方便记忆的解释是：<strong>好比汽车发动，你得先开启引擎让他开一会看看正不正常运行</strong></p>
<p>之后，我们就可以确保接下俩的 <code>LFSR</code>生成的密钥流之间是线性的，但是！是线性的，<strong>也就意味着密钥流之间是孤立的、密钥流也是不安全的，总而言之，其生成的密钥流不能直接作为密码</strong></p>
<p>所以，我们还要对 <code>LFSR</code>生成的密钥流进行 <code>比特重组</code>+<code>线性变换</code>，也就是在进行一次“扩散与混淆”。这一步就是去除了 <code>密钥流</code>之间的<strong>外部线性关系</strong></p>
<p>现在，只要我们<strong>按照给出待加密数据的长度，生成相应长度的密钥流</strong>，然后进行简单的操作：<code>encrypted.append(data[i] ^ keystream_bytes[i])</code>，就完成了加密操作了</p>
<p>上面这步可以看出，密文 = 密钥 ^ 明文，也就是说，ZUC密码是对称密码，所以，解密方式就算把密文当作明文丢进去，按照原来的 <code>key、IV</code>再次运行一次加密即可</p>

      
    </div>
    <footer class="article-footer">
      
      
      
      
      
      
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item" data-aos="zoom-in"><a class="article-tag-list-link" href="/tags/StreamCipher/" rel="tag">StreamCipher</a></li></ul>


    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        <img data-src="https://golden-forest.top/11439df63c8ddcc8282b7b2abe2b7f74.jpg" data-sizes="auto" alt="[Writing] 也无风雨也无晴" class="lazyload">
      
      <a href="/2025/10/23/Writing-25-10-23/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          [Writing] 也无风雨也无晴
        
      </h3>
    </div>
    
  </nav>


</article>









  <section id="comments" data-aos="fade-up">
    <div class="comment-header">
      
      
      <h2 class="comment-title">在这里留下你的足迹...</h2>
      <div class="comment-selector">
        <div class="comment-selector-wrap">
            
            <div class="selector-item" data-selector="gitalk">
              <span>gitalk</span>
            </div>
            
        </div>
      </div>
    </div>
    <div class="comment-content">
      
        <div class="comment gitalk-comment" data-aos="fade-up"
          id="gitalk-comment">
        </div>
      
    </div>
  </section>


</section>
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      
      
      
        2025
      
      <span class="footer-info-sep "></span>
      SkipShot
    </div>
    
      <div>
        基于&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        25.4k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        01:40
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi "></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#zuc%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text"> ZUC算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text"> 预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E8%A3%85%E5%85%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 密钥装入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8lfsr"><span class="toc-number">1.3.</span> <span class="toc-text"> 线性反馈移位寄存器(LFSR)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 初始模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BD%9C%E4%B8%BA%E5%AF%86%E9%92%A5%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 为什么不能直接作为密钥使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E9%87%8D%E7%BB%84br"><span class="toc-number">1.4.</span> <span class="toc-text"> 比特重组(BR)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0f"><span class="toc-number">1.5.</span> <span class="toc-text"> 非线性函数F</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8D%95%E5%85%83r1-r2"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 记忆单元R1、R2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sbox"><span class="toc-number">1.5.2.</span> <span class="toc-text"> Sbox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 线性变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E9%87%8D%E7%BB%84"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 交叉重组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%A2%B3%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text"> 小梳理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86"><span class="toc-number">1.7.</span> <span class="toc-text"> 加密解密</span></a></li></ol></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="SkipShot" class="lazyload">
  <div class="sidebar-author-name">SkipShot</div>
  <div class="sidebar-description">兴趣使然~</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">18</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">6</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">11</div>
  </div>
</div>
<div class="sidebar-social">
  
    <div class="icon-github sidebar-social-icon">
      <a href=https://github.com/tgf668 itemprop="url" target="_blank" aria-label="github" rel="noopener external nofollow noreferrer"></a>
    </div>
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon ">
          &#xe607;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon ">
          &#xe62f;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon ">
          &#xe631;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon ">
          &#xe628;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
      
    
  </div>
  
    
      <div class="sidebar-btn-wrapper">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
    
  
</nav>

    </div>
    
      <div class="site-search">
        <div class="reimu-popup popup">
          <div class="reimu-search">
            <div class="reimu-search-input-icon"></div>
            <div class="reimu-search-input" id="reimu-search-input"></div>
            <div class="popup-btn-close"></div>
          </div>
          <div class="reimu-results">
            <div id="reimu-stats"></div>
            <div id="reimu-hits"></div>
            <div id="reimu-pagination" class="reimu-pagination"></div>
          </div>
          <img class="reimu-bg" src="/images/reimu.png"/>
        </div>
      </div>
    
    
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>





<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>





  <script>
    var ALGOLIA_CONFIG = {
      logo: "/images/algolia_logo.svg",
      algolia: {
        applicationID: "JUZ7GOX38H",
        apiKey: "8be753c0c3d70de624fc33b8c95d4610",
        indexName: "AfterRain",
        hits: {
          "per_page": parseInt("10")
        },
        labels: {
          "input_placeholder": "搜索.....",
          "hits_empty": "未发现与 「${query}」相关内容",
          "hits_stats": "找到${hits}条结果（用时 ${time} ms）"
        }
      }
    };
  </script>
  
<script src="https://npm.webcache.cn/algoliasearch@4.17.1/dist/algoliasearch-lite.umd.js" integrity="sha384-xvLS0jfKuoREs7pqkRI&#x2F;OI8GcqohO5S+jQz7ZBtQXnsXmD+9jDOOY4cL6dCPzlrk" crossorigin="anonymous" defer></script>

  
<script src="https://npm.webcache.cn/instantsearch.js@4.56.1/dist/instantsearch.production.min.js" integrity="sha384-hHJCflT4KBLQyHfKO9vpstIcFKn&#x2F;Y+KHTORelMMEn7mOp2AVPp+7fr03dLgZiV3J" crossorigin="anonymous" defer></script>

  
<script src="/js/algolia_search.js" defer></script>




  
<script src="https://npm.webcache.cn/mouse-firework@0.1.1/dist/index.umd.js" integrity="sha384-8LyaidD9GPxQQgLJO&#x2F;WRw&#x2F;O2h3BoNq&#x2F;ApI&#x2F;ecpvM6RsrCz2qP2ppBXUKihP4V&#x2F;2d" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["var(--red-0)"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>



  
<script src="https://npm.webcache.cn/theme-shokax-pjax@0.0.3/dist/index.umd.js" integrity="sha384-xneY1WY8hOfUzswrE4CrYq35N4BdVcxqxwHPr9zawE&#x2F;jMSCxD+jAPU55x&#x2F;jj3wlf" crossorigin="anonymous"></script>

  <script>
    function loadScripts(scripts, index) {
      if (index < scripts.length) {
        const script = scripts[index];
        const src = script.getAttribute('src');

        const loadScript = (scriptContent) => {
          return new Promise((resolve, reject) => {
            const scriptElement = document.createElement('script');
            if (script.type) {
              scriptElement.type = script.type;
            }
            if (script.src) {
              scriptElement.src = script.src;
              scriptElement.onload = resolve;
              scriptElement.onerror = reject;
            }
            if (scriptContent) {
              scriptElement.text = scriptContent;
            }
            document.head.appendChild(scriptElement);
            if (!script.src) {
              resolve();
            }
          })
          
        }

        ;(src ? loadScript() : loadScript(script.text))
          .then(() => loadScripts(scripts, index + 1))
          .catch(error => {
            console.error(`Failed to load script: ${src || 'inline script'}`, error);
            loadScripts(scripts, index + 1);
          });
      }
    }
    if (window.Pjax) {
      Pjax.prototype.getElements = function() {
        const i18nLanguages = window.REIMU_CONFIG.i18n_languages;
        const baseUrl = window.REIMU_CONFIG.base;
        let basePathname = new URL(baseUrl).pathname;
        if (!basePathname.endsWith('/')) {
          basePathname += '/';  
        }
        const currentUrl = window.location.href;
        const currentPathname = new URL(currentUrl).pathname.replace(basePathname, '');
        const aLinks = document.querySelectorAll('a[href]');
        const pjaxLinks = [];
        for(let i = 0; i < aLinks.length; i++) {
          const aLink = aLinks[i];
          const aLinkHref = aLink.getAttribute('href');
          const isExternal = aLink.getAttribute('target') === '_blank' || aLink.getAttribute('rel')?.includes('noopener');
          if (isExternal || aLinkHref.startsWith('mailto:') || aLinkHref.startsWith('tel:') || aLinkHref.startsWith('javascript:') || aLinkHref.startsWith("data:") || aLinkHref.startsWith("vbscript:")) {
            continue;
          }
          if (!i18nLanguages) {
            // 多语言功能未打开
            pjaxLinks.push(aLink);
            continue;
          }

          const absoluteUrl = new URL(aLinkHref, currentUrl).href;
          const absolutePathname = new URL(absoluteUrl).pathname.replace(basePathname, '');

          if (!absolutePathname || !currentPathname) {
            pjaxLinks.push(aLink);
            continue;
          }

          const currentLangIndex = i18nLanguages.findIndex(lang => currentPathname.startsWith(lang));
          if (currentLangIndex > -1) {
            // 当前属于多语言站点
            const absoluteLangIndex = i18nLanguages.findIndex(lang => absolutePathname.startsWith(lang));
            if (absoluteLangIndex === currentLangIndex) {
              // 同一语言站点，可以使用 pjax
              pjaxLinks.push(aLink);
            }
          } else {
            // 当前属于默认语言站点
            const absoluteLangIndex = i18nLanguages.findIndex(lang => absolutePathname.startsWith(lang));
            if (absoluteLangIndex === -1) {
              // 同一语言站点，可以使用 pjax
              pjaxLinks.push(aLink);
            }
          }
        }
        return pjaxLinks;
      }
    }
    window.Pjax && new window.Pjax({
      selectors: [
        "#header>img",
        "#header>picture",
        "head title",
        "#header-title",
        "#subtitle-wrap",
        "#main",
        "#content",
        ".sidebar-widget",
        ".sidebar-wrapper",
        '#mobile-nav',
        '#lazy-script',
        '#i18n-nav'
      ],
      switches: {
        "#content": function(oldEl, newEl) {
          // for sidebar change
          oldEl.className = newEl.className;
          this.onSwitch();
        },
        "#header-title": Pjax.switches.outerHTML,
        "#subtitle-wrap": Pjax.switches.outerHTML,
        "#main": function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.outerHTML = newEl.outerHTML
          this.onSwitch()
        },
        "#mobile-nav": Pjax.switches.outerHTML,
        '#lazy-script': function(oldEl, newEl) {
          const scripts = [...newEl.querySelectorAll('script')];
          loadScripts(scripts, 0);
          oldEl.innerHTML = newEl.innerHTML
          this.onSwitch()
        },
      },
      cacheBust: false
    })
  </script>
  
<script src="/js/pjax.js"></script>








  
<script src="https://npm.webcache.cn/quicklink@2.3.0/dist/quicklink.umd.js" integrity="sha384-aD7FsuQkS1ohgFKY41fJfeA+Wd&#x2F;QRNnrOd9Bs58K3FzKdJJv8yPnYU8Tnp5z1agS" crossorigin="anonymous"></script>

  <script data-pjax>
    window.quicklink?.listen({
      timeout: 3000,
      priority: true,
      ignores: []
    });
  </script>


<div id="lazy-script">
  <div>
    
      
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "SkipShot",
          title: "[Algorithm] ZUC —— “祖冲之”流密钥算法的代码解释",
          url: "https://skipshot.cn/2025/11/21/Algorithm-25-11-21/",
          excerpt: "简单介绍一下用python写的ZUC（祖冲之算法），不管什么用语言写，其实现思路还是一样的",
          description: "",
          stripContent: " ZUC算法分析  本文写于作者进行密码学课程实验过程中，会以“初学者”的视角去解读。不涉及CTF中的逆向、密码知识，只为做深入理解并为后面复习所用。文章代码源于AI生成，作者专门调过提示词，按照GB/T33133.1—2016标准设计，可能与其他标准或实现顺序有区别，如有问题，请联系作者：（后面开个仓库）   前言 首先，想了解ZUC算法是什么：祖冲之算法，也称为ZUC算法，是一种由中国学者自主设计的同步序列密码算法（流密码），主要用于加密和数据完整性校验。它是中国第一个成为国际密码标准的算法",
          date: "Fri Nov 21 2025 20:25:05 GMT+0800",
          updated: "Wed Nov 26 2025 15:27:01 GMT+0800",
          cover: "https://golden-forest.top/f47066e331aeeefd695c72ea24d732e1.jpg",
        };
      </script>
       
    
      
<script src="https://npm.webcache.cn/mermaid@9.4.3/dist/mermaid.min.js" integrity="sha384-aG3Gai4tbCHF0iXo48HwLoOZyut7mBl50oMC9GD1m75xyHfJDv6w8hD&#x2F;kZRD47aJ" crossorigin="anonymous" data-pjax></script>

      
<script src="https://npm.webcache.cn/dompurify@3.2.4/dist/purify.min.js" integrity="sha384-eEu5CTj3qGvu9PdJuS+YlkNi7d2XxQROAFYOr59zgObtlcux1ae1Il3u7jvdCSWu" crossorigin="anonymous"></script>

      <script data-pjax>
        if (window.mermaid) {
          // https://github.com/mermaid-js/mermaid/issues/1945
          const elementCode = '.mermaid'
          const saveOriginalData = () => {
            return new Promise((resolve, reject) => {
              try {
                let els = _$$(elementCode),
                    count = els.length;
                els.forEach(element => {
                  if (element.getAttribute('data-original-code') == null){
                    element.setAttribute('data-original-code', element.innerHTML)
                  }
                  count--
                  if(count == 0){
                    resolve()
                  }
                });
              } catch (error) {
              reject(error) 
              }
            })
          }
          const resetProcessed = () => {
            return new Promise((resolve, reject) => {
              try {
                let els = _$$(elementCode),
                    count = els.length;
                els.forEach(element => {
                  if(element.getAttribute('data-original-code') != null){
                    element.removeAttribute('data-processed')
                    element.innerHTML = DOMPurify.sanitize(element.getAttribute('data-original-code'))
                  }
                  count--
                  if(count == 0){
                    resolve()
                  }
                });
              } catch (error) {
              reject(error) 
              }
            })
          } 
          const loadMermaid = (theme) => {
            window.mermaid.initialize({theme})
            window.mermaid.init({theme}, _$$(elementCode))
          }
          document.body.addEventListener('dark-theme-set', () => {
            saveOriginalData()
            .then(resetProcessed())
            .then(loadMermaid('dark'))
            .catch(console.error)
          })
          document.body.addEventListener('light-theme-set', () => {
            saveOriginalData()
            .then(resetProcessed())
            .then(loadMermaid('default'))
            .catch(console.error)
          })
          if(localStorage.getItem('dark_mode') == 'true') {
            saveOriginalData()
            .then(resetProcessed())
            .then(loadMermaid('dark'))
            .catch(console.error)
          } else {
            saveOriginalData()
            .then(resetProcessed())
            .then(loadMermaid('default'))
            .catch(console.error)
          }
        }
      </script>
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

        
      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      
        








<script data-pjax>
  var loadScript = (src, integrity) => {
    const script = document.createElement('script');
    script.src = src;
    if (integrity) script.integrity = integrity;
    script.crossOrigin = 'anonymous';
    return script;
  };

  var commentConfigKeys = ['valine', 'waline', 'twikoo', 'gitalk', 'giscus'];
  var commentConfig = {
    valine: {
      enable: false,
      load: () => {
        const container = document.querySelector('.valine-comment');
        if (!container) return;
        container.style.display = 'block';

        const script = loadScript(
          'https://npm.webcache.cn/valine@1.5.1/dist/Valine.min.js',
          'sha384-3ma91AExDeMAZ1rjTjaP8V2A2obQE+s5ltKRwYlwdpArz9xVbp0tF3b0VV2ACNPn'
        );
        script.onload = () => {
          var GUEST_INFO = ['nick', 'mail', 'link'];
          var guest_info = 'nick,mail,link'.split(',').filter((item) => {
            return GUEST_INFO.indexOf(item) > -1
          });
          var recordIP = JSON.parse('true');
          var highlight = JSON.parse('true');
          var visitor = JSON.parse('false');

          if (window.Valine) {
            new Valine({
              el: '.valine-comment',
              appId: "",
              appKey: "",
              placeholder: "Just go go",
              pageSize: '10',
              avatar: 'mp',
              lang: 'zh-cn',
              recordIP: recordIP,
              highlight: highlight,
              visitor: visitor,
              requiredFields: guest_info,
              path: window.location.pathname
            });
          }
        };
        document.head.appendChild(script);
      }
    },
    waline: {
      enable: false,
      load: async () => {
        const container = document.querySelector('.waline-comment');
        if (!container) return;
        container.style.display = 'block';

        let walineInit;
        const walineCdn = 'https://npm.webcache.cn/@waline/client@2.15.8/dist/waline.mjs';
        const walineIntegrity = 'sha384-9sbqJjrfGjbkI6/PI4nU/MvBfEmkkPC4YK9I4zBeMIf1CVCZdCMH/KinBEAZII/5';

        const module = await safeImport(walineCdn, walineIntegrity);
        walineInit = module.init;

        window.walineInstance = walineInit({
          el: '.waline-comment',
          serverURL: '',
          lang: 'zh-CN',
          locale: {},
          emoji: ["https://unpkg.com/@waline/emojis@1.2.0/weibo","https://unpkg.com/@waline/emojis@1.2.0/alus","https://unpkg.com/@waline/emojis@1.2.0/bilibili","https://unpkg.com/@waline/emojis@1.2.0/qq","https://unpkg.com/@waline/emojis@1.2.0/tieba","https://unpkg.com/@waline/emojis@1.2.0/tw-emoji"],
          meta: ["nick","mail","link"],
          requiredMeta: ["nick","mail"],
          wordLimit: JSON.parse('0'),
          comment: true,
          pageSize: JSON.parse('10'),
          dark: 'html[data-theme="dark"]',
          pageview: JSON.parse('true'),
        });
      }
    },
    twikoo: {
      enable: false,
      load: () => {
        const container = document.querySelector('.twikoo-comment');
        if (!container) return;
        container.style.display = 'block';

        const script = loadScript(
          'https://npm.webcache.cn/twikoo@1.6.16/dist/twikoo.all.min.js',
          'sha384-lDHsr5aZmkMS0eKnsUu6e9RWP+dRmn7sgjRAKGOAoXfMyzbUK6Qi86zZK7R+KvRV'
        );

        script.onload = () => {
          if (window.twikoo) {
            twikoo.init({
              envId: '',
              el: '.tcomment',
              region: '',
            })
          }
        } 
        document.head.appendChild(script);
      }
    },
    gitalk: {
      enable: true,
      load: () => {
        const container = document.querySelector('.gitalk-comment');
        if (!container) return;
        container.style.display = 'block';

        const script = loadScript(
          'https://npm.webcache.cn/gitalk@1.8.0/dist/gitalk.min.js',
          'sha384-kspnZUWBoSWwoJHa0hBCXYbHGbhvU/lcEH5O8eVbSDhbPwsiVUTp/aGX/z/5EuMA'
        );

        script.onload = () => {
          if (true) {
            const md5Script = loadScript(
              'https://npm.webcache.cn/blueimp-md5@2.19.0/js/md5.min.js',
              'sha384-JmVtRz6RWiXnA14QbIOJzPuU3MidULOpBP66deeLLyyoF4Tr/gZlbkHkL6vTthxH'
            );
            md5Script.onload = initGitalk;
            document.head.appendChild(md5Script);
          } else {
            initGitalk();
          }
        }
        document.head.appendChild(script);

        function initGitalk() {
          var gitalkId = window.md5 ? window.md5(location.pathname) : location.pathname;
          var gitalk = new Gitalk({
            clientID: 'Ov23liMWG6m0JA6cufIX',
            clientSecret: '10b1d96d82077296b46d66d6031b6ff604e6fb49',
            repo: 'tgf668.github.io',
            owner: 'tgf668',
            admin: "tgf668",
            id: gitalkId, // Ensure uniqueness and length less than 50
            distractionFreeMode: false // Facebook-like distraction free mode
          })
          gitalk.render('gitalk-comment');
        }
      }
    },
    giscus: {
      enable: false,
      load: () => {
        const container = document.querySelector('.giscus-comment');
        if (!container) return;
        container.style.display = 'block';

        // 删除可能已存在的 giscus 脚本和 iframe
        const existingScript = container.querySelector('script[src*="giscus.app/client.js"]');
        if (existingScript) existingScript.remove();
        const existingFrame = document.querySelector('iframe.giscus-frame');
        if (existingFrame) existingFrame.remove();

        const giscusScript = document.createElement('script');
        const domMode = document.documentElement.getAttribute("data-theme");
        giscusScript.src = 'https://giscus.app/client.js';
        giscusScript.setAttribute('data-repo', '');
        giscusScript.setAttribute('data-repo-id', '');
        giscusScript.setAttribute('data-category', ''); 
        giscusScript.setAttribute('data-category-id', '');
        giscusScript.setAttribute('data-mapping', '0');
        giscusScript.setAttribute('data-strict', '0');
        giscusScript.setAttribute('data-reactions-enabled', '1');
        giscusScript.setAttribute('data-emit-metadata', '0');
        giscusScript.setAttribute('data-input-position', 'bottom');
        giscusScript.setAttribute('data-theme', domMode === 'dark' ? 'dark' : 'light');
        giscusScript.setAttribute('data-lang', 'zh-CN');
        giscusScript.setAttribute('crossorigin', 'anonymous');
        giscusScript.async = true;
        container.appendChild(giscusScript);
        document.body.addEventListener('light-theme-set', () => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: { setConfig: { theme: 'light' } } }, 'https://giscus.app');
        });
        document.body.addEventListener('dark-theme-set', () => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: { setConfig: { theme: 'dark' } } }, 'https://giscus.app');
        });
      }
    }
  }
  commentConfig.enable = commentConfigKeys.some(key => commentConfig[key].enable);

  var defaultComment = '';
  if (commentConfig.enable) {
    // 1. 首先检查localStorage中是否有保存的评论类型
    var savedCommentType = localStorage.getItem('commentType');
    
    // 2. 如果localStorage中有值且对应的评论系统可用，就使用它
    if (savedCommentType) {
      if (commentConfig[savedCommentType]?.enable) {
        defaultComment = savedCommentType;
      }
    }
    
    // 3. 如果localStorage无效，检查配置的默认评论系统
    if (!defaultComment) {
      var configDefault = 'gitalk';
      if (commentConfig[configDefault]?.enable) {
        defaultComment = configDefault;
      }
    }
    
    // 4. 如果前两项都无效，按指定顺序找到第一个可用的评论系统
    if (!defaultComment) {
      defaultComment = commentConfigKeys.find(sys => commentConfig[sys].enable) || '';
    }
  }
  function loadComments() {
    if (!commentConfig.enable) return;
    // 评论组件加载状态跟踪
    const loadedComments = {
      valine: false,
      waline: false,
      twikoo: false,
      gitalk: false,
      giscus: false
    };

    // 隐藏所有评论容器
    const hideAllComments = () => {
      const commentContainers = document.querySelectorAll('.comment');
      commentContainers.forEach(container => {
        container.style.display = 'none';
      });
    };

    // 按需加载评论系统
    const loadCommentSystem = (type) => {
      if (loadedComments[type]) {
        // 如果已加载，只需显示对应容器
        document.querySelector(`.${type}-comment`).style.display = 'block';
        return;
      }

      // 根据类型加载对应的脚本
      commentConfig[type]?.load();
      loadedComments[type] = true;
    };

    // 评论组件选择器
    const changeActiveCommentItems = (item) => {
      const commentItems = document.querySelectorAll('.selector-item');
      for (let i = 0; i < commentItems.length; i++) {
        commentItems[i].classList.remove('active');
      }
      item.classList.add('active');

      // 获取要加载的评论系统类型
      const commentType = item.getAttribute('data-selector');

      // 隐藏所有评论系统
      hideAllComments();

      // 加载选中的评论系统
      loadCommentSystem(commentType);
    };

    const commentInit = () => {
      // 评论组件选择器点击事件
      const commentItems = document.querySelectorAll('.selector-item');
      for (let item of commentItems) {
        item.addEventListener('click', () => {
          // 保存选择器状态
          const commentType = item.getAttribute('data-selector');
          window.localStorage.setItem('commentType', commentType);
          // 切换选中状态
          changeActiveCommentItems(item);
        });
      }

      // 检查是否需要加载默认评论系统
      if (defaultComment) {
        const defaultSelectorItem = document.querySelector(`[data-selector="${defaultComment}"]`);
        if (!defaultSelectorItem) return;
        defaultSelectorItem.style.display = 'block';
        defaultSelectorItem.classList.add('active');
        loadCommentSystem(defaultComment);
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', commentInit);
    } else {
      commentInit();
    }
  };
  loadComments();
</script>

      
    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.8.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>



  







  
<script src="https://npm.webcache.cn/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha384-HeUHqi0nVsPUm&#x2F;E0ss7OfnIV&#x2F;yD96JWB8ehZvUuoVax9DpNHL17jj9pdfXHzqDxm" crossorigin="anonymous" defer></script>

  <script data-pjax>
    if (document.readyState === "loading") {
      document.addEventListener('DOMContentLoaded', () => {
        pangu?.spacingPage();
      });
    } else {
      pangu?.spacingPage();
    }
  </script>

    
  </body>
  </html>

